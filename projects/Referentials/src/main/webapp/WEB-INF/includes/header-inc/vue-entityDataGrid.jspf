<%@ page language="java" pageEncoding="UTF-8"%>
<%--
VueJS + Axios simple data admin grid.

Components :
- EntityDataGrid
- EntitySelector : built atop EntityDataGrid, to provide a modal selector

Dependencies :
- header-inc/client-stack.jspf
--%>
<script type="text/javascript">
	// used in EntityDataGrid, because there is no proper Transition@move hook (yet)
	var debouncedScrollIntoView = debounce((element, options)=>{if(element) element.scrollIntoView(options);}, 50);
	// used in EntityDataGrid, to make "viewList" event handling slightly less costly
	var debouncedEmitListChanged = debounce((component)=>{component.$emit("viewList", component.entityList);}, 500);



	// VueJS component (options API)
	var EntityDataGrid = {
		props: {
			resourceName: { // user-friendly and collective name for the resource being edited
				type: String,
				required: true, //default: "YourResource"
			},
			resourceUri: {
				type: String,
				required: true, //default: "/yourAPI/yourResourceBase"
			},
			identifier: {
				type: String,
				required: false,
				default: "id"
			},
			readonly: {
				type: Boolean,
				required: false,
				default: false
			},
			pageSize: {
				type: Number,
				required: false,
				default: 0 /* 0 for no paging, n for fixed page size, and -n for customizable page size (defaulted with n). */
			},
			config : {
				type: Object,
				required: false,
				default: {
					defaultNewEntity: {"id":0},
					columns: [
						{ //------------------  Column config example
							name: "id", // required
							type: Number, // default is String
							label: "Identifier",
							//width: string as CSS, or number as percentage, default is not set.
							editable: false, // "editable" is a shorthand for "insertable" and "updatable", overriding them
							sortable: true,  // default is true
							mandatory: false, // default is false
							format: {pattern:/\d+/, errorMsg:"Must be an integer"} // if length *strictly* over 0, that will set a limit to it
							//renderer : built-in (textarea, none) or a custom VueJS component", default is plain div ("editable=false" set on them at instanciation)
							//editor:    built-in (textarea, none) or a custom VueJS component", default is simple input ("editable=true" set on them at instanciation)
							//... for more info on renderers and editors, see vue-entityAttributeComponents.jspf
//TODO what if we make "column" children components to parameterize their own parent ?
						}
					],
					inferColumns: true, // default is true
					confirmDelete: true, // default is false
					selectRowAction : 'none', // among 'none', 'edit' or function(entity) ; default is 'none'
					payloadProcessor: null // function(entityPayload) which modifies its argument before sending ; default is null
				}
			}
		},
		emits:["viewList",
			"editing"], // "viewList"  : "any shallow change in list" (order, number of items)
		data(){
			return {
				columnList: [],
				entityList: [],
				filteredEntityList:[],
				editingEntity: null,
				editingValidation: new Map(),
				selectedEntity: null,
				_technical_key_seq: 0, // sequence counter, used to uniquely identify rows in grid

				// highlight a row by query string "show-attr"
				showAttribute: null,
				showAttributeValue: null,

				// paging system
				pgSize : Math.abs(this.pageSize),
				pgSizeModifiable : (this.pageSize < 0),
				pgIndex: 0,
			};
		},
		computed:{
			pgCount(){
				if (this.pgSize == 0) return 1;
				let pgCount = this.entityList.length / this.pgSize;
				if (this.pgIndex >= pgCount) this.pgIndex = pgCount - 1;
				return pgCount;
			}
		},
		watch:{
			columnList(){
				this.$nextTick(() => {
					this.$refs.columnTooltip.forEach(el => {
						var tooltip = bootstrap.Tooltip.getOrCreateInstance(el);
					});
				});
			},
			resourceUri(v){
				console.debug("resourceUri changed : ", v);
				this.refreshFullGrid();
			},
		},
		mounted(){
			const searchParams = new URLSearchParams(window.location.search);
			let showAttrParamFrags = /^(.*?):(.*)$/.exec(searchParams.get("show-attr"));
			if (showAttrParamFrags && showAttrParamFrags.length >= 3){
				this.showAttribute = showAttrParamFrags[1];
				this.showAttributeValue = showAttrParamFrags[2];
			}

			this.refreshFullGrid();
		},
		methods:{
			refreshFullGrid(){
				axios_backend.get(this.resourceUri)
				.then(response => {
					this.columnList = this._buildColumnList(response.data);
					this.entityList = this._buildRowList(response.data);
					this.reorderEntityList();
				})
				.catch(error => {
					this.columnList = this._buildColumnList();
					showAxiosErrorDialog(error);
				})
				.finally(() => {
					this.clearEditingRow();
				});
			},
			refreshGridRow(entity) {
				let id = entity[this.identifier];
				let entityUri = this.resourceUri + "/" + id;
				axios_backend.get(entityUri)
				.then(response=>{
					let idx = this.entityList.findIndex(e => (e[this.identifier] == id));
					if (idx >=0) {
						let refreshedEntity = response.data; // heavily relying on failfast behaviour !
						let removedEntity = this.entityList[idx];
						refreshedEntity["#key"] = removedEntity["#key"];
						refreshedEntity["#uri"] = entityUri;
						this.entityList.splice(idx, 1, refreshedEntity);
						//NOT : this.reorderEntityList(); since listed ids not changed
					}
					// more accurate than
					//for (pty in refreshedEntity) {
					//	entity[pty] = refreshedEntity[pty];
					//} because of potentially missing properties
				})
				.catch(error=>{
					showAxiosErrorDialog(error);
				});
			},

			sortByAttr(propertyName, direction){
				this.entityList.sort((a,b) => {
					// isNew() should always be unique and on 1st row, whatever the direction
					if (this.isNew(a)) return -1;
					if (this.isNew(b)) return +1;

					// sort by direct comparison of values
					const aVal = a[propertyName] ?? "";
					const bVal = b[propertyName] ?? "";
					if (aVal > bVal)
						return direction;
					else if (aVal < bVal)
						return -direction;
					else
						return 0; // to keep it stable
				});
				this.reorderEntityList();
			},

			/* can be called for externally set order/filter */
			reorderEntityList(extIds){
				console.debug("reorderEntityList");
				if (typeof extIds === "undefined") extIds = null;
				/* TODO find a proper protocol for external ordering / filtering
				//externally imposed order
				if (extIds != null) {
					for (let i = 0, i < extIds.length ; i++){
						this.entityList
					}

				} else {
					//TODO reset filter marks
					this.filteredEntityList = this.entityList;
				}
				 */
				 this.filteredEntityList = this.entityList;
				debouncedEmitListChanged(this);
			},

			registerMoveEnd(el){
				el.addEventListener("transitionend", this.hMoveEnd);
			},
			unregisterMoveEnd(el){
				el.removeEventListener("transitionend", this.hMoveEnd);
			},
			hMoveEnd(e){
				if (e.propertyName != "transform") return;
				if (!this.editingEntity) return;

				debouncedScrollIntoView(this.$refs.scrollAnchor[0], {block:"nearest"});
				// note: ref="scrollAnchor" sits in a loop, hence the [0]...
			},

			deleteEntity(entity) {
				let handler = () => {
					let id = entity[this.identifier];
					let entityUri =  this.resourceUri + "/" + encodeURIComponent(id);

					axios_backend.delete(entityUri)
					.then(()=>{
						let idx = this.entityList.findIndex(e => (e[this.identifier] == id));
						if (idx >=0) {
							this.entityList.splice(idx, 1);
							this.reorderEntityList();
						}
						//this.refreshFullGrid() more up-to-date, but loses current sort/scroll pos
					})
					.catch(error => {
						showAxiosErrorDialog(error);
					})
					.finally(() => {
						this.clearEditingRow();
					});
				};

				if (this.config.confirmDelete) {
					confirm_dialog(this.resourceName,"Supprimer définitivement la ligne ?",{
						label:'Continuer', class: 'btn-danger', /* autofocus:true,  no reason to make it easy ;-) */
						handler
					}, {
						label:'Abandonner', class: 'btn-secondary',
					});
				} else {
					handler();
				}
			},
			createEntity(){
				let newEntity = deepClone(this.config.defaultNewEntity);
				newEntity["#key"] = -1; // so isNew(newEntity) becomes true
				newEntity["#uri"] = null;
				this.startEditingRow(newEntity);
				this.entityList.unshift(newEntity);
				this.reorderEntityList();
				this.$nextTick(() => {
					this.$refs.scrollAnchor[0].scrollIntoView({block:"center"});
					// note: ref="scrollAnchor" sits in a loop, hence the [0]...
				});
			},
			isNew(entity){
				return entity['#key'] == -1;
			},
			isEditingRow(entity){
				if (this.readonly) return false; // as a safeguard
				if (this.isNew(entity))
					return this.isNew(this.editingEntity);
				else
					return entity["#key"] == (this.editingEntity ? this.editingEntity["#key"] : null);
			},
			startEditingRow(entity){
				if (this.readonly) return; // as a safeguard
				this.showAttribute = this.showAttributeValue = null; // disarm row highlight (until next full refresh, at least)

				this.clearEditingRow();
				this.editingEntity = deepClone(entity);
				this.$emit("editing", this.editingEntity);
			},
			stopEditingRow(){
				let payload = this._buildPayload(this.editingEntity);

				this.validateAllField(payload);
				if (this.editingValidation.size > 0) {
					alert_dialog(this.resourceName,"La saisie n'est pas valide.");
					return; // abort the save
				}

				if (this.isNew(this.editingEntity)) {
					axios_backend.post(this.resourceUri, payload)
					.then(()=>{
						this.clearEditingRow();
						this.refreshFullGrid(); // TODO recapture id and refresh that row ? scroll to it ? keep it at 1st row  ?
					})
					.catch(error=>{
						showAxiosErrorDialog(error);
					});
				} else {
					axios_backend.put(this.resourceUri + "/" + encodeURIComponent(this.editingEntity[this.identifier]), payload)
					.then(()=>{
						let changedEntity = this.entityList.find(e => this.isEditingRow(e));
						this.clearEditingRow();
						this.refreshGridRow(changedEntity);
					})
					.catch(error=>{
						showAxiosErrorDialog(error);
					});
				}
			},
			clearEditingRow(){
				if (this.editingEntity && this.isNew(this.editingEntity)){
					// this.entityList.shift(); may be enough, if only we could be *sure* to never move it ;-)
					let idx = this.entityList.findIndex(e => this.isNew(e));
					if (idx >=0) {
						this.entityList.splice(idx, 1);
						this.reorderEntityList();
					} //... at least there should be only 1
				}
				this.editingEntity = null;
				this.editingValidation.clear();
				this.$emit("editing", this.editingEntity); // == null ;-)

				this.selectedEntity = null; //not necessarily related but...
			},
			/** typically used from outside */
			selectRowById(id){
				let entity = this.entityList.find(e => e[this.identifier] == id);
				this.selectRow(entity);
			},
			selectRow(entity){
				switch(this.config.selectRowAction) {
				case 'none':
					break;
				case 'edit': {
					this.selectedEntity = entity;
					if (!this.isEditingRow(entity)){
						this.startEditingRow(entity);
					}
					break;
				}
				default:
					if (!this.config.selectRowAction) {
						break; /* default : same as 'none' */
					} else if (typeof this.config.selectRowAction == 'function'){
						this.selectedEntity = entity;
						try {
							this.config.selectRowAction(entity);
						} catch(error){
							console.warn("Error calling config.selectRowAction in Component EntityDataGrid", this.config.selectRowAction);
						}
					} else {
						console.warn("Unrecognized config.selectRowAction in Component EntityDataGrid", this.config.selectRowAction);
					}
					break;
				}
			},
			_buildPayload(entityObj) {
				let payloadObj = deepClone(entityObj);

				//clear all technical markers (#key, #uri, etc.)
				for (let attr in payloadObj) {
					if (attr.startsWith("#")) {
						delete payloadObj[attr];
					}
				}

				//custom payload cleaner
				if (this.config.payloadProcessor) {
					this.config.payloadProcessor(payloadObj);
				}

				console.debug("Payload built", payloadObj);
				return payloadObj;
			},

			/* Use config and provided data to build a column list */
			_buildColumnList(rows){
				class Column {
					constructor(columnConfig){
						if (!columnConfig.name) console.error("columnConfig.name must be provided");
						this.name = columnConfig.name;

						this.label = columnConfig.label ?? columnConfig.name;

						this.type = columnConfig.type ?? String; // not used yet, TODO find something to do with that, maybe range constraints for numbers...

						this.visible = true;
						if (typeof columnConfig.visible != 'undefined') {
							this.visible = columnConfig.visible;
						}

						this.widthCSS = null;
						if (typeof columnConfig.width === "number")
							this.widthCSS = columnConfig.width + "%";
						else if (typeof columnConfig.width === "string")
							this.widthCSS = columnConfig.width;

						this.insertable = this.updatable = true;
						this.insertable = (typeof columnConfig.insertable != 'undefined') ? columnConfig.insertable : true;
						this.updatable = (typeof columnConfig.updatable != 'undefined') ? columnConfig.updatable : true;
						if (typeof columnConfig.editable != 'undefined') { // shorthand + override
							this.insertable = this.updatable = columnConfig.editable;
						}

						this.sortable = true;
						if (typeof columnConfig.sortable != 'undefined') {
							this.sortable = columnConfig.sortable;
						}

						this.mandatory = false;
						if (typeof columnConfig.mandatory != 'undefined') {
							this.mandatory = columnConfig.mandatory;
						}

						this.format = null;
						if (columnConfig?.format?.pattern) {
							this.format = columnConfig.format;
							if (!(this.format?.errorMsg)) {
								this.format.errorMsg = "Wrong format (must match "+ this.format.pattern +"))";
							}
						}

						this.renderer = columnConfig.renderer;
						this.editor = columnConfig.editor;

						this.descriptionIcon = null;
						if (typeof columnConfig.descriptionIcon != 'undefined') {
							this.descriptionIcon = columnConfig.descriptionIcon;
						}
						this.description = null;
						if (typeof columnConfig.description != 'undefined') {
							this.description = columnConfig.description;
						}
					}
				}
				let columnDefList = []; // return val

				//1st, use the config
				if (this.config.columns)
				for (let columnConf of this.config.columns) {
					columnDefList.push(new Column(columnConf));
				}

				//2nd, if requested, add auto-inferred columns (properties of 1st row)
				if ((this.config.inferColumns ?? true)
				  && rows instanceof Array && rows.length > 0)
				for (const pty in rows[0]) {
					if (columnDefList.some(c => c.name==pty)) continue;
					columnDefList.push(new Column({name: pty}));
				}

				return columnDefList;
			},
			/* Inject technical key */
			_buildRowList(rows){
				this._technical_key_seq = 0; // reset counter
				for (let row of rows){
					row["#key"] = this._technical_key_seq ++;
					row["#uri"] = this.resourceUri + "/" + row[this.identifier];
				}
				return rows;
			},

			/* Row styling */
			isRowHighlight(entity){
				return (this.showAttribute && this.showAttributeValue)
				  ? entity[this.showAttribute] == this.showAttributeValue
				  : false;
			},

			rowClassObj(entity){
				let returnVal = [];

				if (entity != null && this.selectedEntity != null
				  && this.selectedEntity["#key"] == entity["#key"]) {
					returnVal.push('table-active');
				}
				if (this.isEditingRow(entity)){
					returnVal.push('row-editing');
				}
				if (this.isRowHighlight(entity)){
					returnVal.push('row-highlight');

					//prepare the scroll to that very row !
					this.$nextTick(() => {
						this.$refs.highlightAnchor[0].scrollIntoView({block:"center"});
						// like "scrollAnchor", that sits in a loop, hence the [0]...
					});

				}
				return returnVal;
			},

			/* Column styling */
			columnClassObj(column) {
				return {
					'identifier-col': column.name==this.identifier,
					'mandatory-col' : column.mandatory
				};
			},
			validateField(entity, column){
				let validation = [];
				if (column.mandatory) {
					if (typeof entity[column.name] == 'undefined'
					 || entity[column.name] === null
					 || entity[column.name] === "") {
						validation.push("Champ obligatoire");
					}
				}
				if (column.format) {
					if (!column.format.pattern.test(entity[column.name])){
						validation.push(column.format.errorMsg);
					}
				}

				if (validation.length)
					this.editingValidation.set(column.name, validation);
				else
					this.editingValidation.delete(column.name);
			},
			validateAllField(entity){
				this.editingValidation.clear();
				for (let column of this.columnList){
					this.validateField(entity, column)
				}
			}
		},
		template: '#entityDataList-template'
	};
</script>

<script type="text/x-template" id="entityDataList-template">
	<table class="table table-bordered table-sm caption-top" style="table-layout: fixed">
		<caption class="fs-3 ms-2">{{ resourceName }}</caption>
		<colgroup>
			<col v-if="!readonly" style="width:55px"/><%-- class="btns-first" --%>
			<template v-for="column in columnList.filter(c=>c.visible)">
				<col v-if="column.widthCSS" :style="'width:' + column.widthCSS" /><%-- needs table-layout: fixed --%>
				<col v-else />
			</template>
			<col style="width:55px" /><%-- class="btns-last" --%>
		</colgroup>
		<thead class="shadow sticky-top">
			<tr>
				<th v-if="!readonly" class="btns-first">
					<div>
						<button type="button" class="btn bi bi-plus-lg btn-primary"
						  @click="createEntity(entity)" title="Ajouter une ligne"></button>
						<button type="button" class="btn bi bi-escape btn-secondary"
						  @click.stop="clearEditingRow()" title="Annuler la modification"
						  :disabled="editingEntity == null"
						  v-if="this.config.selectRowAction=='edit'"></button>
					</div>
				</th>
				<th v-for="column in columnList.filter(c=>c.visible)"
				  class="position-relative" :class="columnClassObj(column)"
				  data-bs-toggle="tooltip" :title="column.description" ref="columnTooltip">
					<div>
						{{ column.label }}

						<i v-if="column.descriptionIcon"
						class="position-absolute top-0 end-0 mt-1 me-1 bi" :class="'bi-'+column.descriptionIcon"></i>

						<div v-if="column.sortable" class="sort-buttons">
							<a role="button" class="bi bi-caret-down-fill" @click="sortByAttr(column.name, +1)"></a>
							<a role="button" class="bi bi-caret-up-fill" @click="sortByAttr(column.name, -1)"></a>
						</div>

					</div>
				</th>
				<th class="btns-last">
					<div>
						<button type="button" class="btn bi bi-arrow-clockwise btn-primary"
						@click="refreshFullGrid()" title="Rafraîchir la grille"></button>
					</div>
				</th>
			</tr>
		</thead>
		<tbody>
			<TransitionGroup name="list" @after-enter="registerMoveEnd" @before-leave="unregisterMoveEnd">
			<tr v-for="entity in filteredEntityList" :key="entity['#key']" @click="selectRow(entity)"
			  :class="rowClassObj(entity)" >
				<td v-if="!readonly" class="btns-first">
					<div v-if="isEditingRow(entity)" >
						<button type="button" class="btn bi bi-check-lg btn-success"
						  @click.stop="stopEditingRow()" title="Enregistrer la ligne"
						  ref="scrollAnchor"></button>
						<button type="button" class="btn bi bi-escape btn-secondary"
						  @click.stop="clearEditingRow()" title="Annuler la modification"
						  v-if="this.config.selectRowAction!='edit'"></button>
					</div>
					<div v-else class="position-relative">
						<i class="position-absolute bi-exclamation" v-if="isRowHighlight(entity)" ref="highlightAnchor"></i>
						<%-- TODO put the ref="scrollAnchor" and "highlightAnchor" to another column,
						since this one can be hidden --%>

						<button type="button" class="btn bi bi-pencil" ref="random"
						  @click.stop="startEditingRow(entity)" title="Modifier la ligne"></button>
					</div>
				</td>
				<td v-for="column in columnList.filter(c=>c.visible)" :class="columnClassObj(column)">
					<div v-if="isEditingRow(entity)" >

						<template v-if="(isNew(entity) && column.insertable) || (!isNew(entity) && column.updatable)">
							<textarea v-if="column.editor == 'textarea'"
							  style="width:100%"
							  v-model.trim="editingEntity[column.name]" @input="validateField(editingEntity,column)">
							</textarea>
							<div v-else-if="column.editor == 'none'"
							  class="bi bi-ban text-warning">
							</div>
							<component v-else-if="column.editor" :is="column.editor"
							  v-model.trim="editingEntity[column.name]" :editable="true" @change="validateField(editingEntity,column)"
							  @entities-changed="refreshFullGrid" @entity-changed="refreshGridRow(entity)" >
							</component>
							<input v-else
							  style="width:100%"
							  v-model.trim="editingEntity[column.name]" @input="validateField(editingEntity,column)">
						</template>
						<template v-else>
							<textarea v-if="column.renderer == 'textarea'" disabled
							  style="width:100%"
							  v-model="editingEntity[column.name]">
							</textarea>
							<div v-else-if="column.renderer == 'none'"
							  class="bi bi-ban text-warning">
							</div>
							<component v-else-if="column.renderer" :is="column.renderer"
							  v-model="editingEntity[column.name]" :editable="false"
							  @entities-changed="refreshFullGrid" @entity-changed="refreshGridRow(entity)">
							</component>
							<input v-else disabled
							  style="width:100%"
							  :value="editingEntity[column.name]">
						</template>

						<div v-if="editingValidation.has(column.name)" class="validation">
							<ul>
								<li v-for="msg in editingValidation.get(column.name)">{{msg}}</li>
							</ul>
						</div>
					</div>
					<div v-else >
						<span v-if="column.renderer == 'textarea'" style="white-space:pre-wrap">
							{{ entity[column.name] }}
						</span>
						<div v-else-if="column.renderer == 'none'"
						  class="bi bi-ban text-warning">
						</div>
						<component v-else-if="column.renderer" :is="column.renderer"
						  v-model="entity[column.name]" :editable="false"
						  @entities-changed="refreshFullGrid" @entity-changed="refreshGridRow(entity)">
						</component>
						<div v-else class="text-truncate" :title="entity[column.name]">{{ entity[column.name] }}	</div>
					</div>
				</td>
				<td class="btns-last">
					<div v-if="isEditingRow(entity)" >
						<button v-if="isNew(entity)" type="button" class="btn bi bi-trash3 btn-secondary" disabled></button>
						<button v-else               type="button" class="btn bi bi-trash3 btn-danger"
						  @click.stop="deleteEntity(entity)" title="Supprime la ligne"></button>
					</div>
					<div v-else >
						<button type="button" class="btn bi bi-arrow-clockwise"
						  @click.stop="refreshGridRow(entity)" title="Rafraîchir la ligne"></button>
					</div>
				</td>
			</tr>
			</TransitionGroup>
		</tbody>
		<tfoot v-if="pageSize!=0">
			<tr>
				<td v-if="!readonly" class="btns-first"></td>
				<td :colspan="columnList.filter(c=>c.visible).length">
					<a v-for="i in pgCount" role="nav" @click="pgGoto(i)" :class="{'active': pgIndex==i}">
						{{i}}
					</a>

					Page de
					<input v-if="pgSizeModifiable" v-model="pgSize" type="number" min="1" step="1"></input>
					<span v-else>{{ pgSize }}</span>
				</td>
				<td class="btns-last"></td>
			</tr>
		</tfoot>
	</table>
</script>


<%-- TODO implements multiple selection (ex. for Customer.overrideCarriers) --%>
<script type="text/javascript">
	var EntitySelector = {
		extends: EntityDataGrid,
		props: {
			modelValue: {
			},
			modelModifiers:{
				//capture and ignore
			},
			labelPty:{
				type: String,
				//required: true,
				default: "id"
			}
		},
		emits: ['update:modelValue'],
		components:{
			"embedded-data-grid" : EntityDataGrid
		},
		data:{
			innerConfig: {}
			//note: this.selectedEntity is completely irrelevant, we will use embedded's one directly
		},
		watch: {
			// modelValue: not managed after modal dialog is open
			config:{
				handler(v){
					this.innerConfig = {
						columns: v.columns,
						inferColumns: false,
						selectRowAction : (entity)=>{
							if (typeof v.selectRowAction == "function") v.selectRowAction(entity);
							// empty func to ensure selection is not disabled
						}
					}
				},
				immediate: true
			}
		},
		methods:{
			openModal(){
				var selectedId =  this.modelValue ? this.modelValue[this.identifier] : -1;
				bootstrap.Modal.getOrCreateInstance(this.$refs.entitySelectorDialog).show();
				this.$refs.embedded.selectRowById(selectedId);
			},
			validateEmpty(){
				this.$emit('update:modelValue', null);

			},
			validateSelection(){
				this.$emit('update:modelValue', this.$refs.embedded.selectedEntity);

			}
		},
		template: "#entitySelector-template"
	};
</script>
<script type="text/x-template" id="entitySelector-template">
	<div class="d-flex">
		<input readonly :value="modelValue ? modelValue[labelPty] : '-'" class="w-100 flex-grow-1 flex-shrink-1"/>
		<button v-if="!readonly" class="btn btn-sm flex-grow-0 flex-shrink-0 btn btn-secondary bi bi-table" @click="openModal" />
	</div>
	<div v-for="x in 1" ref="columnTooltip"></div><!-- dummy tooltip -->
	<div class="modal modal-lg" id="entitySelector-dialog" data-bs-backdrop="static" tabindex="-1" ref="entitySelectorDialog">
		<div class="modal-dialog">
			<div class="modal-content">
				<div class="modal-header">
					<h5 class="modal-title">Sélectionnez une valeur</h5>
					<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
				</div>
				<div class="modal-body">
					<embedded-data-grid readonly ref="embedded"
						:resource-name="resourceName" :resource-uri="resourceUri" :identifier="identifier"
						:config="innerConfig" class="table-hover" />
				</div>
				<div class="modal-footer">
					<button type="button" class="btn btn-secondary mx-2" data-bs-dismiss="modal">Abandonner</button>
					<button type="button" class="btn btn-primary" data-bs-dismiss="modal" @click="validateEmpty" >Aucun</button>
					<button type="button" class="btn btn-primary" data-bs-dismiss="modal" @click="validateSelection">Valider</button>
				</div>
			</div>
		</div>
	</div>


<%--
	<table class="table table-bordered table-sm caption-top" style="table-layout: fixed">
		<caption class="fs-3 ms-2">{{ resourceName }}</caption>
		<colgroup>
			<col style="width:55px"/><%-- class="btns-first" -%>
			<template v-for="column in columnList.filter(c=>c.visible)">
				<col v-if="column.widthCSS" :style="'width:' + column.widthCSS" /><%-- needs table-layout: fixed -%>
				<col v-else />
			</template>
			<col style="width:55px" /><%-- class="btns-last" -%>
		</colgroup>
		<thead cla
--%>
</script>
