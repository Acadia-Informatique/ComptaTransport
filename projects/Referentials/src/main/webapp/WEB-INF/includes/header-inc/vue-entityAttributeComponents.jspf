<%@ page language="java" pageEncoding="UTF-8"%>
<%--
VueJS components for rendering and editing some typical entity attributes.

They are all v-model based, and they are listenened to for VueJS event "entities-changed" and "entity-changed"
(resp. for full and single row refresh). Please note that emitting those events is not required for
common rendering (obviously) and editing, since the latter would not trigger a row-level refresh by itself,
but relies on an explicit "saving" action.

Since as cell editors and renderers they cannot be directly configured,
you may need to compose them in custom components, or subclass them.

Components :
- MoneyInput
- AuditingInfoRenderer (auditing info obj)
- AuditingInfoRenderer_IconWithPopover (smaller variant)
- TextTagsComponent ("text tags" tags as String[], editable)

Special :
- EntityActionClient - designed as a composable in a custom renderer :
	- it has no v-model, but uses a "resourceUri" property (e.g. custom renderer can map v-model to "#uri" in EntityDataGrid)
	- it can trigger a client-defined success callback (finer filter on HTTP status, VueJS events emitting, etc.)
	  Events like "entities-changed" or "entity-changed" can be emitted from there (since events in VueJS don't bubble up).
	- it uses QueryParamComponent, as its intended slot child (repeatable). You can also design your own.


Dependencies :
- header-inc/client-stack.jspf
--%>

<script type="text/javascript">
	var MoneyInput = {
		props: ['modelValue', 'modelModifiers', 'decimals'],
		//	modelValue: optional Number ?,
		//	modelModifiers: capture and ignore
		// },
		data(){
			return {
				decimalsInt: 2,
				rounding: 0
			}
		},
		emits: ['update:modelValue'],
		created(){
			if (this.decimals)
				this.decimalsInt = parseInt(this.decimals,10);
			this.rounding = Math.pow(10, this.decimalsInt);
		},
		computed: {
			value: {
				get() {
					return typeof this.modelValue == 'number' ?  this.modelValue.toFixed(this.decimalsInt) : "";
				},
				set(v) {
					v = Number.parseFloat(v);
					v = Number.isNaN(v) ? v = null : Math.round(v * this.rounding) / this.rounding; // shouldn't it be Math.floor ?...maybe not for float decimals :-(
					this.$forceUpdate(); // needed to "visually" truncate the field, when the value is *not* changed by adding 0.00001
					this.$emit('update:modelValue', v);
				}
			}
		},
		template: `<input type="number" :step="1/rounding" v-model.lazy.number="value" class="money-input"/>`
	};

	var AuditingInfoRenderer = {
		props: {
			modelValue: {
				type: Object, // AuditingInfo
			},
		},
		methods: {
			/* expected data format by JaxRS : "2025-10-30T10:24:43Z[UTC]" */
			convertUTC2BrowserLocal(dtUTC){
				if (dtUTC == null || dtUTC == "") return null;
				if (/^(\d{4})-(\d{2})-(\d{2})T(\d{2})\:(\d{2})\:(\d{2})(\.\d+)?Z\[UTC\]$/.test(dtUTC)) {
					dtUTC = dtUTC.slice(0, -("[UTC]".length)); //changed to a JS supported "simplified ISO8061"
					return new Date(Date.parse(dtUTC)).toLocaleString();
				} else {
					return `((Illisible: \${dtUTC}))`;
				}

			}
		},
		computed: {
			local_dateCreated(){return this.convertUTC2BrowserLocal(this.modelValue.dateCreated);},
			local_dateModified(){return this.convertUTC2BrowserLocal(this.modelValue.dateModified);},
		},
		template:
			`<div v-if="modelValue"><ul>
				<li v-if="local_dateCreated">Créé le {{ local_dateCreated  }}</li>
				<li v-if="local_dateModified">Modifié le {{ local_dateModified }}</li>
			</ul></div>
			<em v-else>(nouveau)</em>`// TODO mettre utilisateur (si nouveau, utilis. en cours) quand dispo
	};

	var AuditingInfoRenderer_IconWithPopover = {
		extends: AuditingInfoRenderer,
		methods:{
			clickPopover(e){
				var popover = bootstrap.Popover.getOrCreateInstance(e.target);
				popover.toggle();
			}
		},
		template: `
			<button v-if="modelValue" type="button" class="btn bi bi-info-square"
			  @click.stop="clickPopover" data-bs-trigger="focus"
			  title="Informations d'audit"
			  data-bs-html="true" :data-bs-content=
				"(local_dateCreated ? 'Créé le '+ local_dateCreated : '')
				+(local_dateCreated && local_dateModified ? '<br>' : '')
				+(local_dateModified ? 'Modifié le '+ local_dateModified : '')"></button>
			<em v-else>(nouveau)</em>`// TODO mettre utilisateur (si nouveau, utilis. en cours) quand dispo
	};

	var TextTagsComponent = {
		props: {
			modelValue: {
				type: Array, // of String
				required: true
			},
			modelModifiers: { //capture and ignore this.modelModifiers
				default: () => ({})
			},

			editable: {
				type: Boolean,
				default: false
			},

			selectables: {
				type: Array, // of String
				required: false,
				default: []
			},
			
			tagMaxLength: {
				type: Number,
				default: 16
			}
		},
		emits: ['update:modelValue'],
		data() {
			return {
				areSelectablesShown: false,
			}
		},
		computed: {
			textTagList: {
				get() {return this.modelValue},
				set(value) {this.$emit('update:modelValue', value)}
			}
		},
		methods:{
			showTagPalette(b){
				this.isTagPaletteOpen = b;
			},
			addTextTag(textTag){
				textTag = textTag.substring(0, this.tagMaxLength);
				this.textTagList.push(textTag);

				let deduplicated = new Set(this.textTagList);
				deduplicated = Array.from(deduplicated).sort();
				this.textTagList = deduplicated;
			},
			removeTextTag(textTag){
				this.textTagList = this.textTagList.filter(t => t !== textTag);
			},
			tagStyleClass(textTag){
				if (this.selectables.includes(textTag)){
					return "text-bg-warning";
				} else {
					return "text-bg-info";
				}
			},
			showSelectables(){
				this.areSelectablesShown = true;
			},
			addOriginalTextTag(){
				let originalTagElement = this.$refs.originalTagElement ; // = event.target for VueJS
				//originalTagElement.blur(); not necessarily useful

				let originalTagValue = originalTagElement.innerText.trim();
				if (originalTagValue == ""){
					originalTagElement.innerText = "???"; // as a viewing help
					this.showSelectables(); // as another kind of help
				} else { //if nothing added, maybe need help
					this.addTextTag(originalTagValue);
					originalTagElement.innerText = ""; // clearing
				}
			},

		},
		template: '#TextTags-Component-template'
	};
</script>


<script type="text/x-template" id="TextTags-Component-template">
	<div>
		<div v-for="textTag in textTagList"
		  class="badge rounded-pill me-1 mb-1"
		  :class="tagStyleClass(textTag)">
			{{textTag}}
			<i v-if="editable" class="bi bi-dash-circle-dotted" @click="removeTextTag(textTag)"></i>
		</div>

		<div v-if="editable" class="tag-palette">
			<hr v-if="areSelectablesShown" />
			<div class="badge rounded-pill text-bg-primary me-1 mb-1">
				<span ref="originalTagElement" class="pe-2"
				  contenteditable spellcheck="false" @keyup.enter="addOriginalTextTag"></span>
				<i class="bi bi-plus-circle-dotted" @click="addOriginalTextTag"></i>
			</div>
			<template v-if="areSelectablesShown">
				<div v-for="textTag in selectables"
				  class="badge rounded-pill me-1 mb-1"
				  :class="tagStyleClass(textTag)">
					{{textTag}}
					<i v-if="editable" class="bi bi-plus-circle-dotted" @click="addTextTag(textTag)"></i>
				</div>
			</template>
		</div>
	</div>
</script>


<script type="text/javascript">
<%--
/*
	<restclient resourceUri="/api/customers/15/serve">
		Une assiette composée de :
		<ul>
			<li>Eggs : <qparam type="number" name="eggs"></param></li>
			<li>Spam : <qparam type="text" name="spam"></param></li>
		</ul>
	</restclient>

	const app = createApp({});
	app.component('restclient', EntityActionClient);
	app.component('qparam', QueryParamComponent);
	app.mount('#app');
*/

--%>

	var EntityActionClient = {
		props:{
			resourceUri: String, // (required) Full action URI
			btnText: String, // Text of the button
			btnIcon: String, // Bootstrap icon name, e.g. "copy", "trash"
			needsParams: Boolean, // (optional + no value prop) if present, the client won't fire action HTTP query until it gets some params
			successCallback: Function // optional (remember to call it dynamically with a colon) - a callback with a "response" arg, can throw an error and emit VueJS events
		},
		data(){
			return {
				internalQueryParams: {},
				showParams: false
			};
		},
		provide(){
			return {
				queryParams: Vue.computed({get:()=>this.internalQueryParams, set:(v)=>this.internalQueryParams=v})
			};
		},
		computed:{
			querystring(){
				let urlParams = new URLSearchParams();
				Object.keys(this.internalQueryParams).forEach(k => urlParams.set(k,  this.internalQueryParams[k]));
				return urlParams.toString();
			},
			isReadyForAction(){
				return (!this.needsParams || Object.keys(this.internalQueryParams).length > 0)
			},
			btnReadyClass(){
				return this.isReadyForAction ? "btn-secondary" : "btn-outline-secondary"
			}
		},
		methods:{
			tryAction(){
				if (this.isReadyForAction){
					this.doAction();
				} else {
					this.showParams = true;
				}
			},
			doAction(){
				axios_backend.post(this.resourceUri + "?" + this.querystring) // no payload (yet), but POST is recommended for "not idempotency"
				.then(response=>{
					if (this.successCallback){
						this.successCallback(response);
					}
				})
				.catch(error=>{
					showAxiosErrorDialog(error);
				})
				.finally (()=>{
					this.internalQueryParams={}; //maybe keep it ?... not sure
					this.showParams = false;
				});
			}

		},
		template: "#EntityActionClient-Component-template"
	};


	var QueryParamComponent = {
		inject: ['queryParams'],
		props: ['name'],
		template: `<input v-model="queryParams[name]"/>`
	};

</script>


<script type="text/x-template" id="EntityActionClient-Component-template">
	<div>
		<button type="button" @click="tryAction"
		  class="btn bi" :class="['bi-'+ btnIcon, btnReadyClass]" >
			<span class="ms-1">{{btnText}}</span>
		</button>
		<div v-if="showParams">
			<slot></slot>
		</div>
	</div>
</script>
