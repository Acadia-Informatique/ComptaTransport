<%@ page language="java" pageEncoding="UTF-8"%>
<%--
VueJS components for rendering and editing some typical entity attributes.

They are all v-model based, and they are listenened to for VueJS event "entities-changed" and "entity-changed"
(resp. for full and single row refresh). Please note that emitting those events is not required for
common rendering (obviously) and editing, since the latter would not trigger a row-level refresh by itself,
but relies on an explicit "saving" action.

Since as cell editors and renderers they cannot be directly configured,
you may need to compose them in custom components, or subclass them.

Components :
- MoneyInput
- IconWithPopover (the value is displayed IN the popover, but icons are hints)
- AuditingInfoRenderer (auditing info obj)
- AuditingInfoRenderer_IconWithPopover (smaller variant)
(- TextTagsComponent is its own file "vue-entityTextTagsComponents)

Special :
- EntityActionClient - designed as a composable in a custom renderer :
	- it has no v-model, but uses a "resourceUri" property (e.g. custom renderer can map v-model to "#uri" in EntityDataGrid)
	- it can trigger a client-defined success callback (finer filter on HTTP status, VueJS events emitting, etc.)
	  Events like "entities-changed" or "entity-changed" can be emitted from there (since events in VueJS don't bubble up).
	- it uses QueryParamComponent, as its intended slot child (repeatable). You can also design your own.


Dependencies :
- header-inc/client-stack.jspf
--%>

<script type="text/javascript">
	var MoneyInput = {
		props: ['modelValue', 'modelModifiers', 'decimals'],
		//	modelValue: optional Number ?,
		//	modelModifiers: capture and ignore
		// },
		data(){
			return {
				decimalsInt: 2,
				rounding: 0
			}
		},
		emits: ['update:modelValue'],
		watch: {
			decimals: {
				handler(v){
					if (v) this.decimalsInt = parseInt(v,10);
					this.rounding = Math.pow(10, this.decimalsInt);
				},
				immediate: true
			}
		},
		computed: {
			value: {
				get() {
					return typeof this.modelValue == 'number' ?  this.modelValue.toFixed(this.decimalsInt) : "";
				},
				set(v) {
					v = Number.parseFloat(v);
					v = Number.isNaN(v) ? v = null : Math.round(v * this.rounding) / this.rounding; // shouldn't it be Math.floor ?...maybe not for float decimals :-(
					this.$forceUpdate(); // needed to "visually" truncate the field, when the value is *not* changed by adding 0.00001
					this.$emit('update:modelValue', v);
				}
			}
		},
		template: `<input type="number" :step="1/rounding" v-model.lazy.number="value" class="money-input"/>`
	};

	var IconWithPopover = {
		props: {
			modelValue: {
			},
			icon:{
				type: String,
				required: true
			},
			iconEmpty:{
				type: String,
				required: false
			}
		},
		computed:{
			computedString(){
				if (Vue.toRaw(this.modelValue) instanceof Array) {
					let result ="";
					for (let item of this.modelValue) {
						result += "<li>" + item +"</li>";
					}
					return "<ul>" + result + "</ul>";
				} else {
					return "" + this.modelValue;
				}
			}
		},
		methods:{
			clickPopover(e){
				var popover = bootstrap.Popover.getInstance(e.target);
				if (popover) popover.dispose();
				popover = bootstrap.Popover.getOrCreateInstance(e.target);
				popover.toggle();
			}
		},
		template: `
			<button v-if="modelValue" type="button" class="btn bi" :class="'bi-' + icon"
			  @click.stop="clickPopover" data-bs-trigger="focus"
			  title="Informations d'audit"
			  data-bs-html="true" :data-bs-content="computedString"></button>
			<i v-else-if="iconEmpty" class="btn bi" :class="'bi-' + iconEmpty" />
			<span v-else>&nbsp;&mdash;&nbsp;</span>`
	};

	var AuditingInfoRenderer = {
		props: {
			modelValue: {
				type: Object, // AuditingInfo
			},
		},
		methods: {
			/* expected data format by JaxRS : "2025-10-30T10:24:43Z[UTC]" */
			convertUTC2BrowserLocal(dtUTC){
				if (dtUTC == null || dtUTC == "") return null;
				if (/^(\d{4})-(\d{2})-(\d{2})T(\d{2})\:(\d{2})\:(\d{2})(\.\d+)?Z\[UTC\]$/.test(dtUTC)) {
					dtUTC = dtUTC.slice(0, -("[UTC]".length)); //changed to a JS supported "simplified ISO8601"
					return new Date(Date.parse(dtUTC)).toLocaleString();
				} else {
					return `((Illisible: \${dtUTC}))`;
				}

			}
		},
		computed: {
			local_dateCreated(){return this.convertUTC2BrowserLocal(this.modelValue.dateCreated);},
			local_dateModified(){return this.convertUTC2BrowserLocal(this.modelValue.dateModified);},
		},
		template:
			`<div v-if="modelValue"><ul>
				<li v-if="local_dateCreated">Créé le {{ local_dateCreated  }}</li>
				<li v-if="local_dateModified">Modifié le {{ local_dateModified }}</li>
			</ul></div>
			<em v-else>(nouveau)</em>`// TODO mettre utilisateur (si nouveau, utilis. en cours) quand dispo
	};

	var AuditingInfoRenderer_IconWithPopover = {
		extends: AuditingInfoRenderer,
		methods:{
			clickPopover(e){
				var popover = bootstrap.Popover.getOrCreateInstance(e.target);
				popover.toggle();
			}
		},
		template: `
			<button v-if="modelValue" type="button" class="btn bi bi-info-square"
			  @click.stop="clickPopover" data-bs-trigger="focus"
			  title="Informations d'audit"
			  data-bs-html="true" :data-bs-content=
				"(local_dateCreated ? 'Créé le '+ local_dateCreated : '')
				+(local_dateCreated && local_dateModified ? '<br>' : '')
				+(local_dateModified ? 'Modifié le '+ local_dateModified : '')"></button>
			<em v-else>(nouveau)</em>`// TODO mettre utilisateur (si nouveau, utilis. en cours) quand dispo
	};

	var EntityActionClient = {
		props:{
			resourceUri: String, // (required) Full action URI
			btnText: String, // Text of the button
			btnIcon: String, // Bootstrap icon name, e.g. "copy", "trash"
			needsParams: Boolean, // (optional + no value prop) if present, the client won't fire action HTTP query until it gets some params
			successCallback: Function // optional (remember to call it dynamically with a colon) - a callback with a "response" arg, can throw an error and emit VueJS events
		},
		data(){
			return {
				internalQueryParams: {},
				showParams: false
			};
		},
		provide(){
			return {
				queryParams: Vue.computed({get:()=>this.internalQueryParams, set:(v)=>this.internalQueryParams=v})
			};
		},
		computed:{
			querystring(){
				let urlParams = new URLSearchParams();
				Object.keys(this.internalQueryParams).forEach(k => urlParams.set(k,  this.internalQueryParams[k]));
				return urlParams.toString();
			},
			isReadyForAction(){
				return (!this.needsParams || Object.keys(this.internalQueryParams).length > 0)
			},
			btnReadyClass(){
				return this.isReadyForAction ? "btn-secondary" : "btn-outline-secondary"
			}
		},
		methods:{
			tryAction(){
				if (this.isReadyForAction){
					this.doAction();
				} else {
					this.showParams = true;
				}
			},
			doAction(){
				axios_backend.post(this.resourceUri + "?" + this.querystring) // no payload (yet), but POST is recommended for "not idempotency"
				.then(response=>{
					if (this.successCallback){
						this.successCallback(response);
					}
				})
				.catch(error=>{
					showAxiosErrorDialog(error);
				})
				.finally (()=>{
					this.internalQueryParams={}; //maybe keep it ?... not sure
					this.showParams = false;
				});
			}

		},
		template: "#EntityActionClient-Component-template"
	};


	var QueryParamComponent = {
		inject: ['queryParams'],
		props: ['name'],
		template: `<input v-model="queryParams[name]"/>`
	};

</script>


<script type="text/x-template" id="EntityActionClient-Component-template">
	<div>
		<button type="button" @click="tryAction"
		  class="btn bi" :class="['bi-'+ btnIcon, btnReadyClass]" >
			<span class="ms-1">{{btnText}}</span>
		</button>
		<div v-if="showParams">
			<slot></slot>
		</div>
	</div>
</script>
