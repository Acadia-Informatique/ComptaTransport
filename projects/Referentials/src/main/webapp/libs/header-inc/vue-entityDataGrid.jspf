<script type="text/javascript">
	// VueJS component (options API)
	var EntityDataGrid = {
		props: {
			resourceUri: {
				type: String,
				default: "/yourAPI/yourResourceBase"
			},
			identifier: {
				type: String,
				default: "id"
			},
			defaultNewEntity: {
				type: Object,
				default: {"id":0}
			}
		},
		data(){
			return {
				columnList:[],
				entityList:[],
				editingEntity: null
			};
		},
		computed:{
		},
		methods:{
			refreshGrid(){
				axios_backend.get(this.resourceUri)
				.then(response => {
					if (this.columnList.length==0) {
						//auto-extract column info from 1st element

						for (const fld in response.data[0]) {
							this.columnList.push({name: fld});
						}
					}
					this.entityList = response.data;
				})
				.catch(error => {
					showAxiosErrorDialog(error);
				})
				.finally(() => {
					this.clearEditingRow();
				});
			},

			orderData(propertyName, direction){
				this.entityList.sort((a,b) => {
					// #isNew should always be unique and on 1st row, whatever the direction
					if (a["#isNew"]) return -1;
					if (b["#isNew"]) return +1;

					// sort by direct comparison of values
					const aVal = a[propertyName] ?? "";
					const bVal = b[propertyName] ?? "";
					if (aVal > bVal)
						return direction;
					else if (aVal < bVal)
						return -direction;
					else
						return 0; // to keep it stable
				});
			},

			deleteEntity(entity) {
				let id = entity[this.identifier];
				let entityUri =  this.resourceUri + "/" + encodeURIComponent(id);

				axios_backend.delete(entityUri)
				.then(()=>{
					let idx = this.entityList.findIndex(e => (e[this.identifier] == id));
					if (idx >=0) {
						this.entityList.splice(idx, 1);
					}
					//this.refreshGrid() more up-to-date, but loses current sort/scroll pos
				})
				.catch(error => {
					showAxiosErrorDialog(error);
				})
				.finally(() => {
					this.clearEditingRow();
				});
			},
			createEntity(){
				let newEntity = deepClone(this.defaultNewEntity);
				newEntity["#isNew"] = true;

				this.startEditingRow(newEntity);

				newEntity[this.identifier] = "#new"; //optional: as a potential TransitionGroup key only
				this.entityList.unshift(newEntity);

				this.$nextTick(() => {
					this.$refs.scrollAnchor[0].scrollIntoView({block:"center"});
					// note: ref="scrollAnchor" sits in a loop, hence the [0]...
				});
			},
			isEditingRow(entity){
				if (entity["#isNew"])
					return this.editingEntity["#isNew"];
				else
					return entity[this.identifier] == (this.editingEntity ? this.editingEntity[this.identifier] : null);
			},
			startEditingRow(entity){
				this.clearEditingRow();
				this.editingEntity = deepClone(entity);
			},
			stopEditingRow(){
				let id = this.editingEntity[this.identifier];

				// let entityUri =  this.resourceUri + "/" + encodeURIComponent(id);

				// axios_backend.delete(entityUri)
				// .then(()=>{
				// 	let idx = this.entityList.findIndex(e => (e[this.identifier] == id));
				// 	if (idx >=0) {
				// 		this.entityList.splice(idx, 1);
				// 	}
				// 	//this.refreshGrid() more up-to-date, but loses current sort/scroll pos
				// })
				// .catch(function (error) {
				// 	showAxiosErrorDialog(error);
				// })
				// .finally(function () {
				// 	this.clearEditingRow();
				// });
			},
			clearEditingRow(){
				if (this.editingEntity && this.editingEntity["#isNew"]){
					// this.entityList.shift(); may be enough, if only we could be *sure* to never move it ;-)
					let idx = this.entityList.findIndex(e => e["#isNew"]);
					if (idx >=0) {
						this.entityList.splice(idx, 1);
					} //... at least there should be only 1
				}

				this.editingEntity = null;
			}
		},

		mounted(){
			this.refreshGrid();
		},

		template: '#entityDataList-template'
	};
</script>

<script type="text/x-template" id="entityDataList-template">
	<table class="table table-bordered table-hover table-sm gridTable">
		<thead>
			<tr>
				<th v-for="columnDef in columnList">
					{{ columnDef.name }}
					<a class="bi bi-caret-down-fill" @click="orderData(columnDef.name, +1)"></a>
					<a class="bi bi-caret-up-fill" @click="orderData(columnDef.name, -1)"></a>
				</th>
				<th>
					<button type="button" class="btn bi bi-plus-lg btn-primary" @click="createEntity(entity)"></button>
				</th>
			</tr>
		</thead>
		<tbody>
			<TransitionGroup name="list">
			<tr v-for="entity in entityList" :key="entity[identifier]">

				<td v-for="columnDef in columnList">
					<template v-if="isEditingRow(entity)" >
						<input v-model="editingEntity[columnDef.name]">
					</template>
					<template v-else >
						<div class="text-truncate">{{ entity[columnDef.name] }}	</div>
					</template>
				</td>
				<td>
					<template v-if="isEditingRow(entity)" >
						<button type="button" class="btn bi bi-check-lg btn-success" @click="stopEditingRow()"></button>
						<button type="button" class="btn bi bi-x btn-secondary" @click="clearEditingRow()"></button>

						<button v-if="entity['#isNew']" type="button" class="btn bi bi-trash3 btn-secondary" disabled ref="scrollAnchor"></button>
						<button v-else                  type="button" class="btn bi bi-trash3 btn-danger" @click="deleteEntity(entity)"></button>
					</template>
					<template v-else >
						<button type="button" class="btn bi bi-pencil" @click="startEditingRow(entity)"></button>
					</template>
				</td>
			</tr>
			</TransitionGroup>
		</tbody>

		<!--
		<tfoot>
			<tr>
				<th v-for="columnDef in columnList">
					{{ columnDef.name }}
				</th>
				<th>
					<button type="button" class="btn bi bi-plus-lg btn-primary" @click="createEntity(entity)"></button>
				</th>
			</tr>
		</tfoot>
		-->
	</table>
</script>
