<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

	<title>Prototype "Pricing Grid" engine</title>

	<!-- TODO replace CDN links with self-served -->
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css">

	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">



	<script src="./ConfirmDialog.js"></script>
  </head>
  <body>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>

	<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

	<!-- TODO check Vue / Bootstrap compatibility issues -->

	<script src="./grid.js"></script>

	<script type="text/javascript">

		class CommandeALivrer extends AbstractPricedObject {
			constructor(numero, poids, codePostal){
				super();
				this.numero = numero;
				this.poids = poids;
				this.pays = "France";
				this.codePostal = codePostal;
				this.transporteurHN = "";
			}
			getPPGRawCoordinates(){
				let departement = (this.pays=="France" && this.codePostal &&  this.codePostal.length==5) ? this.codePostal.substring(0,2) : "00";
				return {
						poids : this.poids,
						poidsEntier: Math.ceil(this.poids),
						pays: this.pays, // TODO lookup ISO 3166-1 alpha-2 or alpha-3 codes
						departement,
						transporteurHN: this.transporteurHN
				};
			}
		}
	</script>

	<style>
		/** Bootstrap overrides */
		.accordion {
			--bs-accordion-btn-color: black;
			--bs-accordion-btn-bg: rgb(32, 211, 194);
			--bs-accordion-active-color: white;
			--bs-accordion-active-bg: rgb(0, 0, 172);
		}

		/** App specifics */
		.gridCell {
			position: relative; /* for absolute children*/
		}
		.gridCell input[type=number] {
			width:4em;
			border:lightgrey 1px dotted;
			padding: 0.1em 0.2em;
			text-align:right
		}
		.gridCell .secondary {
			font-size: 80%;
		}

		/** List animations */
		.list-move, /* apply transition to moving elements */
		.list-enter-active,
		.list-leave-active {
			transition: all 0.5s ease;
		}

		.list-enter-from,
		.list-leave-to {
			opacity: 0;
			transform: translateX(30px);
		}

		/* ensure leaving items are taken out of layout flow so that moving
		animations can be calculated correctly. */
		.list-leave-active {
			position: absolute;
		}
	</style>

</head>

<body>
	<div id="pricinggrids-builder">
		<div class="container-fluid mt-2 mb-3"><div class="row">
			<div class="accordion shadow col-12 col-lg-3 order-lg-last" id="tool-pane">
				<div class="accordion-item">
					<h2 class="accordion-header">
						<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
							Test frais livraison
						</button>
					</h2>
					<div id="collapseOne" class="accordion-collapse collapse show" data-bs-parent="#tool-pane">
						<div class="accordion-body">
							<pricingtest-form :ui_state="ui_state"></pricingtest-form>
						</div>
					</div>
				</div>
				<div class="accordion-item">
					<h2 class="accordion-header">
						<button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
							Charger / Enregistrer
						</button>
					</h2>
					<div id="collapseTwo" class="accordion-collapse collapse" data-bs-parent="#tool-pane">
						<div class="accordion-body">
							TODO add some menus
						</div>
					</div>
				</div>
			</div>
			<div class="col-12 col-lg-9">
				<pricinggrids-tabs :ui_state="ui_state"></pricinggrids-tabs>
				<div class="container-fluid overflow-auto">
					<pricinggrids-grid :grid="ui_state.currentGrid" @edit-grid-cell="(cell)=>editGridCell_start(cell)"></pricinggrids-grid>
				</div>
				<pricinggrids-dim-list :ui_state="ui_state"></pricinggrids-dim-list>
			</div>
		</div></div>

		<!-- Modal dialog template for generic ConfirmDialog -->
		<div class="modal" id="modal-confirm-dialog" data-bs-backdrop="static" data-bs-keyboard="false" tabindex="-1">
			<div class="modal-dialog">
				<div class="modal-content">
					<div class="modal-header">
						<h5 class="modal-title"></h5>
						<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
					</div>
					<div class="modal-body">
						<div class="msg"></div>
					</div>
					<div class="modal-footer">
						<button type="button" id="button-template" class="btn col mx-2"></button>
					</div>
				</div>
			</div>
		</div>


		<!-- Modal dialog template for Cell customizer -->
		<div class="modal"  id="grid-cell-customizer" tabindex="-1">
			<div class="modal-dialog modal-dialog-scrollable modal-fullscreen-md-down">
				<div class="modal-content">
					<div class="modal-header">
						<h5 class="modal-title">Cellule de grille</h5>
						<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
					</div>
					<div class="modal-body">
						<ul>
							<div class="alert alert-warning">TRAVAUX EN COURS</div>
							<li><input type="radio" v-model="ui_state.editingPolicyChoice" value="copy">
								Réutiliser la précédente :</input>
								TODO BOUTON COPIE DE LA PRECEDENTE OUVERTE
							</li>
							<li><input type="radio" v-model="ui_state.editingPolicyChoice" value="FixedPrice">
								Prix Fixe</input>
								<ul>
									<li>de <input type="number" v-model="ui_state.editingPolicyCopy1.price"></input></li>
								</ul>
							</li>
							<li><input type="radio" v-model="ui_state.editingPolicyChoice" value="PerVolumePrice">
								Au volume</input>
								<ul>
									<li>Prix au
										<select v-model="ui_state.editingPolicyCopy2.attribute" required>
											<option disabled value="">Coordonnée brute</option>
											<option v-for="k in numericRawCoords" :value="k">
												{{ k }}
											</option>
										</select>,
									</li>
									<li>arrondi au <input type="number" step="1" min="1" v-model.number="ui_state.editingPolicyCopy2.rounding"> supérieur</input></li>
									<li>de : <input type="number" v-model.number="ui_state.editingPolicyCopy2.price"> par unité</input>
								</ul>
							</li>
							<li><input type="radio" v-model="ui_state.editingPolicyChoice" value="DelegatedPrice">
								Voir une autre grille</input>
								<ul>
									<li>
										<select v-model="ui_state.editingPolicyCopy3.delegated_gridName" required>
											<option disabled value="">Choisissez une grille</option>
											<option v-for="k in ui_state.system.grids.map(g=>g.name)" :value="k">
												{{ k }}
											</option>
											<!-- TODO filter out current -->
										</select>
									</li>
									<li>
										Frais supplémentaire (optionnel) <input type="number" v-model="ui_state.editingPolicyCopy3.delegated_additiveAmount"></input>
									</li>
								</ul>
							</li>
						</ul>
					</div>
					<div class="modal-footer">
						<button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abandonner</button>
						<button type="button" class="btn btn-primary" @click="editGridCell_end">Sauvegarder</button>
					</div>
				</div>
			</div>
		</div>
	</div>



	<!-- =========================================================== -->
	<!-- =============== Vue components ============================ -->

	<!-- ========== (some) component templates ============== -->
	<script type="text/x-template" id="PricingTest-Form-template">
		<form id="" class="" @submit.prevent="">
			<div class="mb-3">
				<label class="form-label" for="inputPoids">Poids</label>
				<input type="number" step="0.1" min="0" lang="en-US"
				 class="form-control" id="inputPoids" placeholder="Poids (en kg)"
				 v-model.number="ui_state.testPricedObj.poids">
			</div>
			<div class="mb-3">
				<label class="form-label" for="inputPostCode">Code postal</label>
				<input type="text" maxlength="5"
				 class="form-control" id="inputPostCode" placeholder="Code postal"
				 v-model.trim="ui_state.testPricedObj.codePostal">
			</div>
			<div class="mb-3">
				<label class="form-label" for="inputCountry">Pays</label>
				<select class="form-control" id="inputCountry" v-model="ui_state.testPricedObj.pays">
					<option value="">(Inconnu)</option>
					<option value="France">France</option>
					<option value="Belgique">Belgique</option>
					<option value="Hongrie">Hongrie</option>
				</select>
			</div>
			<div class="mb-3">
				<label class="form-label" for="inputTransporteurHN">Transporteur HN</label>
				<select class="form-control" id="inputTransporteurHN" v-model="ui_state.testPricedObj.transporteurHN">
					<option disabled value="">Choisissez un transport</option>
					<option value="Schenker std">Schenker std</option>
					<option value="Schenker premium">Schenker premium</option>
					<option value="Geodis MES">Geodis MES</option>
					<option value="Geodis ATX">Geodis ATX</option>
				</select>
			</div>




			{{ void(returnVal = ui_state.system.applyGrid(ui_state.currentGrid.name, ui_state.testPricedObj) )}}
			<div> <!--class="text-truncate" -->{{ JSON.stringify(returnVal) }}</div>

			<div class="fs-2">Amount : {{ returnVal?.amount }}</div>
		</form>
	</script>

	<!-- ========== component logic ============== -->
	<script type="module">
		let typicalRawCoords = Object.entries(new CommandeALivrer("", 0, "01000").getPPGRawCoordinates()); //arguably typical ?...

		const numericRawCoords =  typicalRawCoords.filter(([k,v]) => typeof v == "number").map(([k,v]) => k);
		const stringRawCoords =  typicalRawCoords.filter(([k,v]) =>typeof v == "string").map(([k,v]) => k);

		/* shared state for the page */
		//const gridBuilderApp_UI = Vue.reactive( ui_state); TODO need explicit call ?!

		const gridBuilderApp = Vue.createApp({
			data() {
				return {
					numericRawCoords,
					stringRawCoords,

					ui_state: { // TODO utiliser un bus global ?...
						//start TODO XXXXXXXXXXXXXXXXXXX funky defaults
						system: theSystem,
						currentGrid: theSystem.grids[0], //ensure it exists ?

						// TODO encore plus Q&D que d'hab', for demo
						editingPolicyCell: null,
						editingPolicyCopy0: null,
						editingPolicyChoice: "copy", //or a real policy type
						editingPolicyCopy1: {
							type: "FixedPrice",
							price: 0
						},
						editingPolicyCopy2: {
							type: "PerVolumePrice",
							attribute: "poids",
							rounding: 10,
							price: 0
						},
						editingPolicyCopy3: {
							type: "DelegatedPrice",
							delegated_gridName: "",
							delegated_additiveAmount: 0
						},
						//end TODO XXXXXXXXXXXXXXXXXXX

						editingDimName: "",
						editingDimCopy: null,


						testPricedObj: new CommandeALivrer("FCxxxxxx", 10 /*kg*/, "93420"),

						confirmCancel: function(callback){
							let continueFunc = ()=>{
								this.editingDimName = "";
								this.editingDimCopy = null;
								callback();
							};

							if (this.editingDimCopy) {
								confirm_dialog("Dimension","Modification en cours, abandonner ?",{
									label:'Continuer', class: 'btn-primary',
									handler: continueFunc
								}, {
									label:'Annuler', class: 'btn-secondary',
								});
							} else {
								continueFunc();
							}

						}
					}
				}
			},
			methods: {
				editGridCell_start(cell){
					this.ui_state.editingPolicyCell = cell;

					this.ui_state.editingPolicyCopy0 = JSON.parse(JSON.stringify(cell?.policy));
					switch(cell?.policy?.type){
						case "FixedPrice": {
							this.ui_state.editingPolicyChoice = "FixedPrice";
							this.ui_state.editingPolicyCopy1 = JSON.parse(JSON.stringify(cell.policy));
						} break;
						case "PerVolumePrice": {
							this.ui_state.editingPolicyChoice = "PerVolumePrice";
							this.ui_state.editingPolicyCopy2 = JSON.parse(JSON.stringify(cell.policy));
						} break;
						case "DelegatedPrice": {
							this.ui_state.editingPolicyChoice = "DelegatedPrice";
							this.ui_state.editingPolicyCopy3 = JSON.parse(JSON.stringify(cell.policy));
						} break;
						default:
					}
				},
				editGridCell_end(){
					if (!this.ui_state.editingPolicyCell) return;
					switch(this.ui_state.editingPolicyChoice){
						case "FixedPrice": {
							this.ui_state.editingPolicyCell.policy = JSON.parse(JSON.stringify(this.ui_state.editingPolicyCopy1));
						} break;
						case "PerVolumePrice": {
							this.ui_state.editingPolicyCell.policy = JSON.parse(JSON.stringify(this.ui_state.editingPolicyCopy2));
						} break;
						case "DelegatedPrice": {
							this.ui_state.editingPolicyCell.policy = JSON.parse(JSON.stringify(this.ui_state.editingPolicyCopy3));
						} break;
						default:
					}
				}
				// TODO UI state management (loading, etc.)


			},
		});


		var PricingGrids_Tabs = {
			props: {
				ui_state: Object
			},
			methods: {
				newGrid: function(){
					let name = window.prompt("Nom de la nouvelle grille"); //TODO real grid management, with delete and rename/relabel
					if (name) {
						let newGrid = new PricingGrid(name);
						newGrid.updateCellsFromDimensions();
						this.ui_state.system.grids.push(newGrid);
					}
				},
				selectGrid: function(name){
					this.ui_state.confirmCancel(
						()=>{ this.ui_state.currentGrid = this.ui_state.system.findGridByName(name); }
					);
				}

			},
			template: `
				<ul class="nav nav-tabs">
					<li v-for="grid in ui_state.system.grids"
						class="nav-item">
						<a href="#" class="nav-link" :class="{active: ui_state.currentGrid.name == grid.name}" @click="selectGrid(grid.name)">{{grid.name}}</a>
					</li>
					<li class="nav-item">
						<a href="#" class="nav-link bi bi-plus-lg" @click="newGrid"></a>
					</li>
				</ul>`
		};


		var _AbstractDimension = {
			props: {
				dimension: Object,
				ui_state: Object
			},
			data(){
				return {
					numericRawCoords,
					stringRawCoords
				}
			},
			computed: {
				isEditing(){
					return (this.dimension.name == this.ui_state.editingDimName);
				}
			}
		};


		var PricingGrids_DimensionList = {
			props: {
				ui_state: Object
			},
			data(){
				return {
					newDimType:"ThresholdCategory"
				}
			},
			methods: {
				newDimension(){
					this.ui_state.confirmCancel(()=>{
						let newDim = this.ui_state.currentGrid.addNewDimension(this.newDimType);
						this.editDimension_start(null, newDim.name);
					});
				},
				removeDimension(idx){
					let removedDim = this.ui_state.currentGrid.dimensions[idx];
					confirm_dialog("Dimension",`Êtes-vous sûr de vouloir supprimer la dimension "${removedDim.name}" ?
									(Vous perdrez alors toutes les cellules correspondantes)`,{
						label:'Continuer', class: 'btn-primary',
						handler : ()=>{
							this.ui_state.currentGrid.removeDimension(idx);
							this.ui_state.editingDimName = "";
							this.ui_state.editingDimCopy = null;
						}
					}, {
						label:'Abandonner', class: 'btn-secondary',
					});
				},
				moveDimension(fromIdx, offset){
					let dimensions = this.ui_state.currentGrid.dimensions;
					let toIdx = fromIdx + offset;
					if (fromIdx < 0 || fromIdx >= dimensions.length) throw new Error("'From' index out of range");
					if (toIdx < 0 || toIdx >= dimensions.length) throw new Error("'To' index out of range");
					[dimensions[fromIdx], dimensions[toIdx]] = [dimensions[toIdx], dimensions[fromIdx]];
				},
				isMovable(fromIdx, offset){
					let dimensions = this.ui_state.currentGrid.dimensions;
					let toIdx = fromIdx + offset;
					return (toIdx >= 0 && toIdx < dimensions.length);
				},
				editDimension_start(event, name){
					this.ui_state.confirmCancel(()=>{
						if (event) this._clearEditing(event);

						let editingDim = this.ui_state.currentGrid.dimensions.find( dim => dim.name == name);
						if (!editingDim) throw new Error(`Dimension "${name}" cannot be found for editing.`);

						this.ui_state.editingDimCopy = JSON.parse(JSON.stringify(editingDim));
						this.ui_state.editingDimName = name;
					});
				},
				editDimension_end(event){
					let form = event.target.closest("form.needs-validation")

					// 1) Validate form
					// 1.a) name unicity check
					let name_field = form.querySelector("#dim-name");
					let oldName = this.ui_state.editingDimName;
					let newName = this.ui_state.editingDimCopy.name;

					if (newName != oldName
					  &&  this.ui_state.currentGrid.dimensions.find( dim => dim.name == newName)){
						name_field.setCustomValidity("dupe");
					} else {
						name_field.setCustomValidity("");
					}
					// 1.b) validate other attribs
					if (!form.checkValidity()) {
						event.preventDefault();
						event.stopPropagation();
						form.classList.add('was-validated')
						return;
					}

					// 2) Save form
					let editingDim = this.ui_state.currentGrid.dimensions.find( dim => dim.name == oldName);
					if (!editingDim) throw new Error("Cannot save to dimension : " + oldName);

					// 2.a) adjust new name if needed
					if (oldName != newName) this.ui_state.currentGrid.renameDimension(oldName, newName);

					// 2.b) prune all categories with no value
					this.ui_state.editingDimCopy.categories = this.ui_state.editingDimCopy.categories.filter(c => !(typeof c.value == "string" && c.value==""));

					// 2.c) ... *then* copy other attribs
					Object.assign(editingDim, this.ui_state.editingDimCopy);

					// 2.d) update cells for categories change
					this.ui_state.currentGrid.updateCellsFromDimensions();

					this._clearEditing(event);
				},

				editDimension_abort(event){
					this._clearEditing(event);
				},

				_clearEditing(event){
					let form = event.target.closest("form.needs-validation")
					form.classList.remove('was-validated');

					this.ui_state.editingDimName = "";
					this.ui_state.editingDimCopy = null;
				},


			},
			components :{
				ThresholdCategoryDimension:{
					extends: _AbstractDimension,
					computed:{
						categoryThresholdList: {
							get() {
								return this.ui_state.editingDimCopy.categories.map(c => c.value).join(" ; ");
							},
							set(value) {
								let asCleanStr = value.replaceAll(/[^\d.]+/g, ";");
								let asNumbers = asCleanStr.split(";").map(s => parseFloat(s, 10)).filter(n => n >=0);
								let asUniqueNumbers = [ ...new Set(asNumbers)];
								let categoryValues = asUniqueNumbers.sort((a, b) => a - b);

								let newCategories = categoryValues.map( v => ({value:v}) );
								this.ui_state.editingDimCopy.categories = newCategories;
							}
						}
					},
					template:
						`<div v-if="isEditing">
							<div class="input-group mb-3">
								<input id="dim-name" class="form-control" placeholder="Nom interne" v-model.trim="ui_state.editingDimCopy.name" required>
								<span class="input-group-text">par seuil de</span>
								<select class="form-control" v-model="ui_state.editingDimCopy.raw_name" required>
									<option disabled value="">Coordonnée brute</option>
									<option v-for="k in numericRawCoords" :value="k">
										{{ k }}
									</option>
								</select>
								<div class="invalid-feedback">
									Nom interne unique et non-vide (et court de préférence)
								</div>
							</div>
							<label class="form-label" for="dim-categoryThresholdList">Liste des seuils</label>
							<input class="form-control" id="dim-categoryThresholdList" v-model.lazy="categoryThresholdList">
						</div>
						<div v-else>
							"{{ dimension.name }}" : par seuil de "{{ dimension.raw_name }}"
							({{ dimension.categories.map(c=>c.value).join(", ") }})
						</div>`
				},
				EnumCategoryDimension:{
					extends: _AbstractDimension,
					computed: {
						categoryAlerts(){
							let categoryAlerts = [];
							const categories = this.ui_state.editingDimCopy.categories;

							// category values (="names")
							let categoryNames = categories.map(c => c.value);
							if (categoryNames.includes("")){
								categoryAlerts.push(`Attention, les catégories sans nom seront supprimées !`);
							}

							categoryNames = categoryNames.filter(v => v!="");
							{
								const dupes =  Array.from(new Set(categoryNames.filter((item, i) => categoryNames.indexOf(item) !== i)));
								if (dupes.length > 0){
									categoryAlerts.push(`Les noms de catégorie suivants sont en doublon : ${dupes}.`);
								}
							}

							// intra-category dupes
							for (const cat of categories){
								const dupes =  Array.from(new Set(cat.enum.filter((item, i) => cat.enum.indexOf(item) !== i)));
								if (dupes.length > 0){
									categoryAlerts.push(`La catégorie "${cat.value}" contient les doublons suivants : ${dupes}.`);
								}
							}
							// cross-category dupes
							for (let x=0; x<categories.length; x++){
								for (let y=0; y<categories.length; y++){
									if (x >= y) continue;
									const catx = categories[x], caty = categories[y];
									const sx = new Set(catx.enum), sy = new Set(caty.enum);
									//const dupes = sx.intersection(sy); exists since... 2024. A bit too fresh for me
									const dupes = Array.from(new Set([...sx].filter(v => sy.has(v))));
									if (dupes.length > 0){
										categoryAlerts.push(`Les catégories "${catx.value}" et "${caty.value}" contiennent en commun : ${dupes}.`);
									}
								}
							}
							return categoryAlerts;
						}
					},
					methods:{
						addCategory(){
							this.ui_state.editingDimCopy.categories.push({value:"<Nouv.>", enum:[]}); //TODO defaulting
						}
					},
					template:
						`<div v-if="isEditing">
							<div class="input-group mb-3">
								<input id="dim-name" class="form-control" placeholder="Nom interne" v-model.trim="ui_state.editingDimCopy.name" required>
								<span class="input-group-text">par seuil de</span>
								<select class="form-control" v-model="ui_state.editingDimCopy.raw_name" required>
									<option disabled value="">Coordonnée brute</option>
									<option v-for="k in stringRawCoords" :value="k">
										{{ k }}
									</option>
								</select>
								<div class="invalid-feedback">
									Nom interne unique et non-vide (et court de préférence)
								</div>
							</div>

							<label class="form-label">Catégories</label>
							<div class="container">
								<div class="input-group" v-for="cat in ui_state.editingDimCopy.categories">
									<input class="form-control" v-model.trim="cat.value" style="flex-grow: 0; flex-basis:6em">
									<span class="input-group-text">:</span>
									<splitting-input class="form-control" v-model="cat.enum"></splitting-input>
								</div>
								<button type="button" @click="addCategory" class="btn btn-outline-secondary bi bi-plus-lg"></button>
								<ul v-if="categoryAlerts.length>0" class="alert alert-warning fade show" role="alert">
									<li v-for="ca in categoryAlerts">{{ ca }}</li>
								</ul>
							</div>
						</div>
						<div v-else>
							"{{ dimension.name }}" : par seuil de "{{ dimension.raw_name }}"
							<ul>
								<li v-for="cat in dimension.categories">
									<strong>{{ cat.value }}</strong> : <em>{{ cat.enum.join(", ") }}</em>
								</li>
							</ul>
						</div>`
				},


			},

			template: `
				<ul class="list-group">
					<TransitionGroup name="list">
					<li v-for="(dim, dimIdx) in ui_state.currentGrid.dimensions" class="list-group-item" :key="dim.name">
						<form class="container-fluid needs-validation"><div class="row">
							<div class="dimension-buttons d-inline-flex flex-row flex-md-column col-md-2">
								<template v-if="dim.name==ui_state.editingDimName">
									<button type="button" class="btn btn-outline-primary mb-1" @click="editDimension_abort">Cancel</button>
									<button type="button" class="btn btn-outline-primary mb-1" @click="removeDimension(dimIdx)">Delete</button>
									<button type="button" class="btn btn-outline-primary mb-1" @click="editDimension_end">Save</button>
								</template>
								<template v-else>
									<button type="button" class="btn btn-secondary mb-1 bi bi-pencil-square" @click="editDimension_start($event, dim.name)"></button>
									<button type="button" class="btn btn-secondary mb-1 bi bi-caret-up-fill" @click="moveDimension(dimIdx,-1)" :disabled="!isMovable(dimIdx,-1)"></button>
									<button type="button" class="btn btn-secondary mb-1 bi bi-caret-down-fill" @click="moveDimension(dimIdx,+1)" :disabled="!isMovable(dimIdx,+1)"></button>
								</template>
							</div>
							<div class="col-10">
								<component :is="dim.type+'Dimension'"
									:dimension="dim" :ui_state="ui_state"></component>
							</div>
						</div></form>
					</li>
					</TransitionGroup>
					<li class="list-group-item">
						<button class="btn btn-secondary" @click="newDimension">
							Ajouter une dimension
						</button>
						de type
						<select v-model="newDimType">
							<option disabled value="">Type de dimension</option>
							<option value="ThresholdCategory">Par seuil</option>
							<option value="EnumCategory">Par énumération</option>
						</select>
					</li>

				</ul>
			`
		};


		var PricingGrids_GridCell = {
			props: {
				cell: Object
			},
			emits: ["editGridCell"],
			template: `
				<div class="gridCell">
					<a class="position-absolute top-0 end-0" data-bs-toggle="modal" data-bs-target="#grid-cell-customizer"
					  @click="$emit('editGridCell', cell)">
						<i class="bi bi-three-dots-vertical"></i>
					</a>
					<template v-if="cell">
						<template v-if="cell.policy">
							<template v-if="cell.policy.type=='FixedPrice'">
								<input type="number" v-model.number="cell.policy.price">
							</template>
							<template v-else-if="cell.policy.type=='PerVolumePrice'">
								<input type="number" v-model.number="cell.policy.price">*{{cell.policy.attribute}}
								<div class="secondary">
									(arrondi à <input type="number" step="1" min="1" v-model.number="cell.policy.rounding">)
								</div>
							</template>
							<template v-else-if="cell.policy.type=='DelegatedPrice'">
								voir grille {{ cell.policy.delegated_gridName }}
								{{ cell.policy.delegated_additiveAmount??0==0
								  ? "+ ajout "+ cell.policy.delegated_additiveAmount + "€"
								  : "" }}
							</template>
							<template v-else>
								<span class="badge bg-danger">UNKNOWN</span>
								 {{ cell.policy.type }}
							</template>
						</template>
						<template v-else>
							<span class="badge bg-danger">NO POLICY</span>
						</template>
					</template>
					<template v-else>
						<span class="badge bg-danger">NO CELL</span>
					</template>
				</div>
				`
		};

		var PricingGrids_Grid = {
			props: {
				grid: Object
				//TODO pass the full grid system : a policy can reference another grid !
			},
			computed:{
				dimensionCount(){
					return this.grid.dimensions.length;
				}
			},
			emits: ["editGridCell"],
			methods:{
				categoryLabel(dimension, category, categoryIndex){
					let label;
					switch (dimension.type) {
						case "ThresholdCategory":
							let nextCategory = categoryIndex < dimension.categories.length - 1
							 ? dimension.categories[categoryIndex+1]
							 : null;
							 switch (dimension.raw_name){
								case "poids" : {
									label = nextCategory
									 ? `${category.value} - ${nextCategory.value} kg`
									 : `${category.value}+ kg`;
								} break;
								case "poidsEntier": {
									label = nextCategory
									 ? `${category.value} - ${nextCategory.value - 1} kg`
									 : `${category.value}+ kg`;
								} break;
							 }

						case "EnumCategory":
						default:
					}
					return label ?? category.value;
				}
			},
			emits: ["editGridCell"] /* bubble up*/,
			template: `
				<table class="table table-bordered">
					<template v-if="dimensionCount==0">
						<thead>
							<tr>
								<th>Toutes livraisons</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<pricinggrids-gridcell
									  @edit-grid-cell="(cell)=>$emit('editGridCell', cell)"
									  :cell="grid.gridCellAt({})">
									</pricinggrids-gridcell>
								</td>
							</tr>
						</tbody>
					</template>
					<template v-else-if="dimensionCount==1">
						{{void(
							dim0 = this.grid.dimensions[0]
						)}}
						<thead>
							<tr>
								<th>{{ dim0.name }}</th>
								<th>Prix</th>
							</tr>
						</thead>
						<tbody>
							<tr v-for="(categ_dim0, categIdx_dim0) in dim0.categories">
								<th>{{ categoryLabel(dim0, categ_dim0, categIdx_dim0) }}</th>
								<td>
									<pricinggrids-gridcell
									  @edit-grid-cell="(cell)=>$emit('editGridCell', cell)"
									  :cell="grid.gridCellAt({[dim0.name]: categ_dim0.value})">
									</pricinggrids-gridcell>
								</td>
							</tr>
						</tbody>
					</template>
					<template v-else-if="dimensionCount==2">
						{{void(
							dim0 = this.grid.dimensions[0],
							dim1 = this.grid.dimensions[1]
						)}}
						<thead>
							<tr>
								<th rowspan="2">{{ dim0.name }}</th>
								<th :colspan="dim1.categories.length">
									{{ dim1.name }}
								</th>
							</tr>
							<tr>
								<th v-for="(categ_dim1, categIdx_dim1) in dim1.categories">
									{{ categoryLabel(dim1, categ_dim1, categIdx_dim1) }}
								</th>
							</tr>
						</thead>
						<tbody>
							<tr v-for="(categ_dim0, categIdx_dim0) in dim0.categories" >
								<th>{{ categoryLabel(dim0, categ_dim0, categIdx_dim0) }}</th>
								<td v-for="categ_dim1 in dim1.categories">
									<pricinggrids-gridcell
									  @edit-grid-cell="(cell)=>$emit('editGridCell', cell)"
									  :cell="grid.gridCellAt({[dim0.name]: categ_dim0.value,[dim1.name]: categ_dim1.value})">
									</pricinggrids-gridcell>
								</td>
							</tr>
						</tbody>
					</template>
					<template v-else-if="dimensionCount==3">
						{{void(
							dim0 = grid.dimensions[0],
							dim1 = grid.dimensions[1],
							dim2 = grid.dimensions[2]
						)}}
						<thead>
							<tr>
								<th rowspan="4">{{ dim0.name }}</th>
								<th :colspan="dim2.categories.length * dim1.categories.length">
									{{ dim2.name }}
								</th>
							</tr>
							<tr>
								<th v-for="(categ_dim2, categIdx_dim2) in dim2.categories" :colspan="dim1.categories.length">
									{{ categoryLabel(dim2, categ_dim2, categIdx_dim2) }}
								</th>
							</tr>
							<tr>
								<th v-for="categ_dim2 in dim2.categories" :colspan="dim1.categories.length">
									{{ dim1.name }}
								</th>
							</tr>
							<tr>
								<template v-for="categ_dim2 in dim2.categories">
								<th v-for="(categ_dim1, categIdx_dim1) in dim1.categories">
									{{ categoryLabel(dim1, categ_dim1, categIdx_dim1) }}
								</th>
								</template>
							</tr>
						</thead>
						<tbody>
							<tr v-for="(categ_dim0, categIdx_dim0) in dim0.categories" >
								<th>{{ categoryLabel(dim0, categ_dim0, categIdx_dim0) }}</th>
								<template v-for="categ_dim2 in dim2.categories">
								<td v-for="categ_dim1 in dim1.categories">
									<pricinggrids-gridcell
									  @edit-grid-cell="(cell)=>$emit('editGridCell', cell)"
									  :cell="grid.gridCellAt({[dim0.name]: categ_dim0.value,[dim1.name]: categ_dim1.value, [dim2.name]: categ_dim2.value})">
									</pricinggrids-gridcell>
								</td>
								</template>
							</tr>
						</tbody>
					</template>
					<template v-else>
						<tbody><tr><td>
							Dimensions &gt; 3 non support&eacute; !
						</td></tr></tbody>
					</template>
				</table>` // Note : une solution générale est possible, mais un peu illisible... et moins souple sur le rendu.
		};




		var PricingTest_Form = {
			props: {
				ui_state: Object
			},
			template: '#PricingTest-Form-template'
		};

		/** Splitting to array */
		var SplittingInput = {
			props: {
				modelValue: Array
			},
			emits: ['update:modelValue'],
			computed: {
				value: {
					get() {
						return this.modelValue.join(" ; ");
					},
					set(value) {
						let arrValue =  value.split(";").map(s => s.trim());
						//if you arrValue.sort(); you'll need to .lazy the v-model in template
						this.$emit('update:modelValue', arrValue);
					}
				}
			},
			template: `<input v-model="value" />`
		};



		gridBuilderApp.component("splitting-input", SplittingInput);

		gridBuilderApp.component("pricinggrids-tabs", PricingGrids_Tabs);

		gridBuilderApp.component("pricinggrids-grid", PricingGrids_Grid);
		gridBuilderApp.component("pricinggrids-gridcell", PricingGrids_GridCell);

		gridBuilderApp.component("pricinggrids-dim-list", PricingGrids_DimensionList);


		gridBuilderApp.component("pricingtest-form", PricingTest_Form);

		gridBuilderApp.mount('#pricinggrids-builder');
	</script>

</body>



</html>
