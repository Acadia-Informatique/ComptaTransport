<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

	<title>Prototype "Pricing Grid" engine</title>

	<!-- TODO replace CDN links with self-served -->
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css">

	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">



	<script src="./ConfirmDialog.js"></script>
  </head>
  <body>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>

	<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

	<!-- TODO check Vue / Bootstrap compatibility issues -->

	<script src="./grid.js"></script>

	<script type="text/javascript">

		//TODO hydration functions


	</script>

	<style>
		.gridCell input {
			width:4em;
			border:lightgrey 1px dotted;
			padding: 0.2em 0.5em;
		}

		/** List animations */
		.list-move, /* apply transition to moving elements */
		.list-enter-active,
		.list-leave-active {
		transition: all 0.5s ease;
		}

		.list-enter-from,
		.list-leave-to {
		opacity: 0;
		transform: translateX(30px);
		}

		/* ensure leaving items are taken out of layout flow so that moving
		animations can be calculated correctly. */
		.list-leave-active {
		position: absolute;
		}
	</style>

</head>

<body>
	<div id="grid-builder">
		<div class="container-fluid"><div class="row">
			<div class="accordion shadow col-12 col-lg-3 order-lg-last" id="tool-pane">
				<div class="accordion-item">
					<h2 class="accordion-header">
						<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
							Test shipping fee
						</button>
					</h2>
					<div id="collapseOne" class="accordion-collapse collapse show" data-bs-parent="#tool-pane">
						<div class="accordion-body">
							<pricingtest-form :ui_state="ui_state"></pricingtest-form>
						</div>
					</div>
				</div>
				<div class="accordion-item">
					<h2 class="accordion-header">
						<button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
							Load / Save Data
						</button>
					</h2>
					<div id="collapseTwo" class="accordion-collapse collapse" data-bs-parent="#tool-pane">
						<div class="accordion-body">
							TODO add some menus
						</div>
					</div>
				</div>
			</div>
			<div class="col-12 col-lg-9">
				<pricinggrids-tabs :ui_state="ui_state"></pricinggrids-tabs>
				<div class="container-fluid overflow-auto">
					<pricinggrids-grid :grid="ui_state.currentGrid"></pricinggrids-grid>
				</div>
				<pricinggrids-dim-list :ui_state="ui_state"></pricinggrids-dim-list>
			</div>
		</div></div>

		<!-- Modal dialog template for generic ConfirmDialog -->
		<div class="modal" id="modal-confirm-dialog" data-bs-backdrop="static" data-bs-keyboard="false" tabindex="-1">
			<div class="modal-dialog">
				<div class="modal-content">
					<div class="modal-header">
						<h5 class="modal-title"></h5>
						<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
					</div>
					<div class="modal-body">
						<div class="msg"></div>
					</div>
					<div class="modal-footer">
						<button type="button" id="button-template" class="btn col mx-2"></button>
					</div>
				</div>
			</div>
		</div>


		<!-- Modal dialog template for Cell customizer -->
		<div class="modal"  id="grid-cell-customizer" tabindex="-1">
			<div class="modal-dialog modal-dialog-scrollable modal-fullscreen-md-down">
				<div class="modal-content">
					<div class="modal-header">
						<h5 class="modal-title">Cellule de grille</h5>
						<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
					</div>
					<div class="modal-body">
							policy: {
								type: "PerVolumePrice",
								attribute: "poids",
								rounding: 10,
								price: 4.4
							}

						<input type="radio" value="FixedPrice" v-model="ui_state.editingPolicyCopy.type">Forfait</input> <br>
						<input type="radio" value="PerVolumePrice" v-model="ui_state.editingPolicyCopy.type">Au volume</input><br>
					</div>
					<div class="modal-footer">
						<button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abandonner</button>
						<button type="button" class="btn btn-primary">Sauvegarder</button>
					</div>
				</div>
			</div>
		</div>
	</div>



	<!-- =========================================================== -->
	<!-- =============== Vue components ============================ -->

	<!-- ========== (some) component templates ============== -->
	<script type="text/x-template" id="PricingTest-Form-template">
		<form id="" class="" @submit.prevent="">
			<div class="mb-3">
				<label class="form-label" for="inputPoids">Poids</label>
				<input type="number" step="0.1" min="0" lang="en-US"
				 class="form-control" id="inputPoids" placeholder="Poids (en kg)"
				 v-model.number="ui_state.testPricedObj.poids">
			</div>
			<div class="mb-3">
				<label class="form-label" for="inputPostCode">Code postal</label>
				<input type="text" maxlength="5"
				 class="form-control" id="inputPostCode" placeholder="Code postal"
				 v-model.trim="ui_state.testPricedObj.codePostal">
			</div>
			{{ void({gridCell, amount} = ui_state.currentGrid.apply(ui_state.testPricedObj)) }}
			<div> <!--class="text-truncate" -->{{ JSON.stringify(gridCell) }}</div>

			Amount : {{ amount }}
		</form>
	</script>

	<!-- ========== component logic ============== -->
	<script type="module">

		/* shared state for the page */
		//const gridBuilderApp_UI = Vue.reactive( ui_state); TODO need explicit call ?!

		const gridBuilderApp = Vue.createApp({
			data() {
				return {
					ui_state: {
						system: theSystem, //TODO start with empty / localstored
						currentGrid: theSystem.grids[0], //TODO react to selection

						editingPolicyCopy: {
							type: "PerVolumePrice",
							attribute: "poids",
							rounding: 10,
							price: 4.4
						}, //TODO XXXXXXXXXXXXXXXXXXX

						editingDimName: "",
						editingDimCopy: null,


						testPricedObj: new CommandeALivrer("FCxxxxxx", 302 /*kg*/, "93420"),

						confirmCancel: function(callback){
							let continueFunc = ()=>{
								this.editingDimName = "";
								this.editingDimCopy = null;
								callback();
							};

							if (this.editingDimCopy) {
								confirm_dialog("Dimension","Modification en cours, abandonner ?",{
									label:'Continuer', class: 'btn-primary',
									handler: continueFunc
								}, {
									label:'Annuler', class: 'btn-secondary',
								});
							} else {
								continueFunc();
							}

						}
					}
				}
			},
			methods: {
				// TODO UI state management (loading, etc.)


			},
		});


		var PricingGrids_Tabs = {
			props: {
				ui_state: Object
			},
			methods: {
				newGrid: function(){
					let name = "Nouvelle grille"; //TODO find next good name
					this.ui_state.system.grids.push(
						new PricingGrid(name)
					);
				},
				selectGrid: function(name){
					this.ui_state.confirmCancel(
						()=>{ this.ui_state.currentGrid = this.ui_state.system.findGridByName(name); }
					);
				}

			},
			template: `
				<ul class="nav nav-pills">
					<li v-for="grid in ui_state.system.grids"
						class="nav-item">
						<a href="#" class="nav-link" :class="{active: ui_state.currentGrid.name == grid.name}" @click="selectGrid(grid.name)">{{grid.name}}</a>
					</li>
					<li class="nav-item">
						<a href="#" class="nav-link bg-secondary text-white" @click="newGrid"> + </a>
					</li>
				</ul>`
		};


		var _AbstractDimension = {
			props: {
				dimension: Object,
				ui_state: Object
			},
			data(){
				let typicalRawCoords = Object.entries(this.ui_state.testPricedObj.getPPGRawCoordinates()); //arguably typical ?...

				let numericRawCoords =  typicalRawCoords.filter(([k,v]) => typeof v == "number").map(([k,v]) => k);
				let stringRawCoords =  typicalRawCoords.filter(([k,v]) =>typeof v == "string").map(([k,v]) => k);
				return {
					numericRawCoords,
					stringRawCoords
				}
			},
			computed: {
				isEditing(){
					return (this.dimension.name == this.ui_state.editingDimName);
				}
			}
		};


		var PricingGrids_DimensionList = {
			props: {
				ui_state: Object
			},
			data(){
				return {
					newDimType:"ThresholdCategory"
				}
			},
			methods: {
				newDimension(){
					this.ui_state.confirmCancel(()=>{
						let newDim = this.ui_state.currentGrid.addNewDimension(this.newDimType);
						this.editDimension_start(null, newDim.name);
					});
				},
				removeDimension(idx){
					let removedDim = this.ui_state.currentGrid.dimensions[idx];
					confirm_dialog("Dimension",`Êtes-vous sûr de vouloir supprimer la dimension "${removedDim.name}" ?`,{
						label:'Continuer', class: 'btn-primary',
						handler : ()=>{
							this.ui_state.currentGrid.removeDimension(idx);
							this.ui_state.editingDimName = "";
							this.ui_state.editingDimCopy = null;
						}
					}, {
						label:'Abandonner', class: 'btn-secondary',
					});
				},
				moveDimension(fromIdx, offset){
					let dimensions = this.ui_state.currentGrid.dimensions;
					let toIdx = fromIdx + offset;
					if (fromIdx < 0 || fromIdx >= dimensions.length) throw new Error("'From' index out of range");
					if (toIdx < 0 || toIdx >= dimensions.length) throw new Error("'To' index out of range");
					[dimensions[fromIdx], dimensions[toIdx]] = [dimensions[toIdx], dimensions[fromIdx]];
				},
				isMovable(fromIdx, offset){
					let dimensions = this.ui_state.currentGrid.dimensions;
					let toIdx = fromIdx + offset;
					return (toIdx >= 0 && toIdx < dimensions.length);
				},
				editDimension_start(event, name){
					this.ui_state.confirmCancel(()=>{
						if (event) this._clearEditing(event);

						let editingDim = this.ui_state.currentGrid.dimensions.find( dim => dim.name == name);
						if (!editingDim) throw new Error(`Dimension "${name}" cannot be found for editing.`);

						this.ui_state.editingDimCopy = JSON.parse(JSON.stringify(editingDim));
						this.ui_state.editingDimName = name;
					});
				},
				editDimension_end(event){
					let form = event.target.closest("form.needs-validation")

					// 1) Validate form
					// 1.a) name unicity check
					let name_field = form.querySelector("#dim-name");
					let oldName = this.ui_state.editingDimName;
					let newName = this.ui_state.editingDimCopy.name;

					if (newName != oldName
					  &&  this.ui_state.currentGrid.dimensions.find( dim => dim.name == newName)){
						name_field.setCustomValidity("dupe");
					} else {
						name_field.setCustomValidity("");
					}
					// 1.b) validate other attribs
					if (!form.checkValidity()) {
						event.preventDefault();
						event.stopPropagation();
						form.classList.add('was-validated')
						return;
					}

					// 2) Save form
					let editingDim = this.ui_state.currentGrid.dimensions.find( dim => dim.name == oldName);
					if (!editingDim) throw new Error("Cannot save to dimension : " + oldName);

					// 2.a) adjust new name if needed
					if (oldName != newName) this.ui_state.currentGrid.renameDimension(oldName, newName);

					// 2.b) prune all categories with no value
					this.ui_state.editingDimCopy.categories = this.ui_state.editingDimCopy.categories.filter(c => !(typeof c.value == "string" && c.value==""));

					// 2.c) ... *then* copy other attribs
					Object.assign(editingDim, this.ui_state.editingDimCopy);

					// 2.d) update cells for categories change
					this.ui_state.currentGrid.updateCellsFromDimensions();

					this._clearEditing(event);
				},

				editDimension_abort(event){
					this._clearEditing(event);
				},

				_clearEditing(event){
					let form = event.target.closest("form.needs-validation")
					form.classList.remove('was-validated');

					this.ui_state.editingDimName = "";
					this.ui_state.editingDimCopy = null;
				},


			},
			components :{
				ThresholdCategoryDimension:{
					extends: _AbstractDimension,
					computed:{
						categoryThresholdList: {
							get() {
								return this.ui_state.editingDimCopy.categories.map(c => c.value).join(";");
							},
							set(value) {
								let asCleanStr = value.replaceAll(/[^\d.]+/g, ";");
								let asNumbers = asCleanStr.split(";").map(s => parseFloat(s, 10)).filter(n => n >=0);
								let asUniqueNumbers = [ ...new Set(asNumbers)];
								let categoryValues = asUniqueNumbers.sort((a, b) => a - b);

								let newCategories = categoryValues.map( v => ({value:v}) );
								this.ui_state.editingDimCopy.categories = newCategories;
							}
						}
					},
					template:
						`<div v-if="isEditing">
							<div class="input-group mb-3">
								<input id="dim-name" class="form-control" placeholder="Nom interne" v-model.trim="ui_state.editingDimCopy.name" required>
								<span class="input-group-text">par seuil de</span>
								<select class="form-control" v-model="ui_state.editingDimCopy.raw_name" required>
									<option disabled value="">Coordonnée brute</option>
									<option v-for="k in numericRawCoords" :value="k">
										{{ k }}
									</option>
								</select>
								<div class="invalid-feedback">
									Nom interne unique et non-vide (et court de préférence)
								</div>
							</div>
							<label class="form-label" for="dim-categoryThresholdList">Liste des seuils</label>
							<input class="form-control" id="dim-categoryThresholdList" v-model.lazy="categoryThresholdList">
						</div>
						<div v-else>
							"{{ dimension.name }}" : par seuil de "{{ dimension.raw_name }}"
							(<span v-for="(cat, i) in dimension.categories">{{i?" - ":""}}{{ cat.value }}</span>)
						</div>`
				},
				EnumCategoryDimension:{
					extends: _AbstractDimension,
					computed: {
						categoryAlerts(){
							let categoryAlerts = [];
							const categories = this.ui_state.editingDimCopy.categories;

							// category values (="names")
							let categoryNames = categories.map(c => c.value);
							if (categoryNames.includes("")){
								categoryAlerts.push(`Attention, les catégories sans nom seront supprimées !`);
							}

							categoryNames = categoryNames.filter(v => v!="");
							{
								const dupes =  Array.from(new Set(categoryNames.filter((item, i) => categoryNames.indexOf(item) !== i)));
								if (dupes.length > 0){
									categoryAlerts.push(`Les noms de catégorie suivants sont en doublon : ${dupes}.`);
								}
							}

							// intra-category dupes
							for (const cat of categories){
								const dupes =  Array.from(new Set(cat.enum.filter((item, i) => cat.enum.indexOf(item) !== i)));
								if (dupes.length > 0){
									categoryAlerts.push(`La catégorie "${cat.value}" contient les doublons suivants : ${dupes}.`);
								}
							}
							// cross-category dupes
							for (let x=0; x<categories.length; x++){
								for (let y=0; y<categories.length; y++){
									if (x >= y) continue;
									const catx = categories[x], caty = categories[y];
									const sx = new Set(catx.enum), sy = new Set(caty.enum);
									//const dupes = sx.intersection(sy); exists since... 2024. A bit too fresh for me
									const dupes = Array.from(new Set([...sx].filter(v => sy.has(v))));
									if (dupes.length > 0){
										categoryAlerts.push(`Les catégories "${catx.value}" et "${caty.value}" contiennent en commun : ${dupes}.`);
									}
								}
							}
							return categoryAlerts;
						}
					},
					methods:{
						addCategory(){
							this.ui_state.editingDimCopy.categories.push({value:"<Nouv.>", enum:[]}); //TODO defaulting
						}
					},
					template:
						`<div v-if="isEditing">
							<div class="input-group mb-3">
								<input id="dim-name" class="form-control" placeholder="Nom interne" v-model.trim="ui_state.editingDimCopy.name" required>
								<span class="input-group-text">par seuil de</span>
								<select class="form-control" v-model="ui_state.editingDimCopy.raw_name" required>
									<option disabled value="">Coordonnée brute</option>
									<option v-for="k in stringRawCoords" :value="k">
										{{ k }}
									</option>
								</select>
								<div class="invalid-feedback">
									Nom interne unique et non-vide (et court de préférence)
								</div>
							</div>

							<label class="form-label">Catégories</label>
							<div class="container">
								<div class="input-group" v-for="cat in ui_state.editingDimCopy.categories">
									<input class="form-control" v-model.trim="cat.value" style="flex-grow: 0; flex-basis:6em">
									<span class="input-group-text">:</span>
									<splitting-input class="form-control" v-model="cat.enum"></splitting-input>
								</div>
								<button type="button" @click="addCategory" class="btn btn-outline-secondary bi bi-plus-lg"></button>
								<ul v-if="categoryAlerts.length>0" class="alert alert-warning fade show" role="alert">
									<li v-for="ca in categoryAlerts">{{ ca }}</li>
								</ul>
							</div>
						</div>
						<div v-else>
							"{{ dimension.name }}" : par seuil de "{{ dimension.raw_name }}"
							<ul>
								<li v-for="cat in dimension.categories">
									<strong>{{ cat.value }}</strong> : <em>{{ cat.enum.join(", ") }}</em>
								</li>
							</ul>
						</div>`
				},


			},

			template: `
				<ul class="list-group">
					<TransitionGroup name="list">
					<li v-for="(dim, dimIdx) in ui_state.currentGrid.dimensions" class="list-group-item" :key="dim.name">
						<form class="container-fluid needs-validation"><div class="row">
							<div class="dimension-buttons d-inline-flex flex-row flex-md-column col-md-2">
								<template v-if="dim.name==ui_state.editingDimName">
									<button type="button" class="btn btn-outline-primary mb-1" @click="editDimension_abort">Cancel</button>
									<button type="button" class="btn btn-outline-primary mb-1" @click="removeDimension(dimIdx)">Delete</button>
									<button type="button" class="btn btn-outline-primary mb-1" @click="editDimension_end">Save</button>
								</template>
								<template v-else>
									<button type="button" class="btn btn-secondary mb-1 bi bi-pencil-square" @click="editDimension_start($event, dim.name)"></button>
									<button type="button" class="btn btn-secondary mb-1 bi bi-caret-up-fill" @click="moveDimension(dimIdx,-1)" :disabled="!isMovable(dimIdx,-1)"></button>
									<button type="button" class="btn btn-secondary mb-1 bi bi-caret-down-fill" @click="moveDimension(dimIdx,+1)" :disabled="!isMovable(dimIdx,+1)"></button>
								</template>
							</div>
							<div class="col-10">
								<component :is="dim.type+'Dimension'"
									:dimension="dim" :ui_state="ui_state"></component>
							</div>
						</div></form>
					</li>
					</TransitionGroup>
					<li class="list-group-item">
						<button class="btn btn-secondary" @click="newDimension">
							Ajouter une dimension
						</button>
						de type
						<select v-model="newDimType">
							<option disabled value="">Type de dimension</option>
							<option value="ThresholdCategory">Par seuil</option>
							<option value="EnumCategory">Par énumération</option>
						</select>
					</li>

				</ul>
			`
		};


		var PricingGrids_GridCell = {
			props: {
				cell: Object
			},
			template: `
				<div class="gridCell">
					<a class="float-end" data-bs-toggle="modal" data-bs-target="#grid-cell-customizer">
						<i class="bi bi-three-dots"></i>
					</a>
					<template v-if="cell">
						<template v-if="cell.policy">
							<template v-if="cell.policy.type=='FixedPrice'">
								<input v-model.number="cell.policy.price">
							</template>
							<template v-if="cell.policy.type=='PerVolumePrice'">
								<input v-model.number="cell.policy.price">*{{cell.policy.attribute}}
								(arrondi à <input type="number" step="1" min="1" v-model.number="cell.policy.rounding">)
							</template>
						</template>
						<template v-else>
							<span class="badge bg-danger">NO POLICY</span>
						</template>
					</template>
					<template v-else>
						<span class="badge bg-danger">NO CELL</span>
					</template>
				</div>
				`
		};

		var PricingGrids_Grid = {
			props: {
				grid: Object
				//TODO pass the full grid system : a policy can reference another grid !
			},
			computed:{
				dimensionCount(){
					return this.grid.dimensions.length;
				}
			},
			methods:{
				categoryLabel(dimension, category, categoryIndex){
					let label;
					switch (dimension.type) {
						case "ThresholdCategory":
							let nextCategory = categoryIndex < dimension.categories.length - 1
							 ? dimension.categories[categoryIndex+1]
							 : null;
							 switch (dimension.raw_name){
								case "poids" : {
									label = nextCategory
									 ? `${category.value} - ${nextCategory.value} kg`
									 : `${category.value}+ kg`;
								} break;
								case "poidsEntier": {
									label = nextCategory
									 ? `${category.value} - ${nextCategory.value - 1} kg`
									 : `${category.value}+ kg`;
								} break;
							 }

						case "EnumCategory":
						default:
					}
					return label ?? category.value;
				}
			},

			template: `
				<table class="table table-bordered">
					<template v-if="dimensionCount==0">
						<thead>
							<tr>
								<th>Toutes livraisons</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><pricinggrids-gridcell :cell="grid.gridCellAt({
								})"></pricinggrids-gridcell></td>
							</tr>
						</tbody>
					</template>
					<template v-else-if="dimensionCount==1">
						{{void(
							dim0 = this.grid.dimensions[0]
						)}}
						<thead>
							<tr>
								<th>{{ dim0.name }}</th>
								<th>Prix</th>
							</tr>
						</thead>
						<tbody>
							<tr v-for="(categ_dim0, categIdx_dim0) in dim0.categories">
								<th>{{ categoryLabel(dim0, categ_dim0, categIdx_dim0) }}</th>
								<td>
									<pricinggrids-gridcell
										:cell="grid.gridCellAt({[dim0.name]: categ_dim0.value})">
									</pricinggrids-gridcell>
								</td>
							</tr>
						</tbody>
					</template>
					<template v-else-if="dimensionCount==2">
						{{void(
							dim0 = this.grid.dimensions[0],
							dim1 = this.grid.dimensions[1]
						)}}
						<thead>
							<tr>
								<th rowspan="2">{{ dim0.name }}</th>
								<th :colspan="dim1.categories.length">
									{{ dim1.name }}
								</th>
							</tr>
							<tr>
								<th v-for="(categ_dim1, categIdx_dim1) in dim1.categories">
									{{ categoryLabel(dim1, categ_dim1, categIdx_dim1) }}
								</th>
							</tr>
						</thead>
						<tbody>
							<tr v-for="(categ_dim0, categIdx_dim0) in dim0.categories" >
								<th>{{ categoryLabel(dim0, categ_dim0, categIdx_dim0) }}</th>
								<td v-for="categ_dim1 in dim1.categories">
									<pricinggrids-gridcell
										:cell="grid.gridCellAt({[dim0.name]: categ_dim0.value,[dim1.name]: categ_dim1.value})">
									</pricinggrids-gridcell>
								</td>
							</tr>
						</tbody>
					</template>
					<template v-else-if="dimensionCount==3">
						{{void(
							dim0 = grid.dimensions[0],
							dim1 = grid.dimensions[1],
							dim2 = grid.dimensions[2]
						)}}
						<thead>
							<tr>
								<th rowspan="4">{{ dim0.name }}</th>
								<th :colspan="dim2.categories.length * dim1.categories.length">
									{{ dim2.name }}
								</th>
							</tr>
							<tr>
								<th v-for="(categ_dim2, categIdx_dim2) in dim2.categories" :colspan="dim1.categories.length">
									{{ categoryLabel(dim2, categ_dim2, categIdx_dim2) }}
								</th>
							</tr>
							<tr>
								<th v-for="categ_dim2 in dim2.categories" :colspan="dim1.categories.length">
									{{ dim1.name }}
								</th>
							</tr>
							<tr>
								<template v-for="categ_dim2 in dim2.categories">
								<th v-for="(categ_dim1, categIdx_dim1) in dim1.categories">
									{{ categoryLabel(dim1, categ_dim1, categIdx_dim1) }}
								</th>
								</template>
							</tr>
						</thead>
						<tbody>
							<tr v-for="(categ_dim0, categIdx_dim0) in dim0.categories" >
								<th>{{ categoryLabel(dim0, categ_dim0, categIdx_dim0) }}</th>
								<template v-for="categ_dim2 in dim2.categories">
								<td v-for="categ_dim1 in dim1.categories">
									<pricinggrids-gridcell
										:cell="grid.gridCellAt({[dim0.name]: categ_dim0.value,[dim1.name]: categ_dim1.value, [dim2.name]: categ_dim2.value})">
									</pricinggrids-gridcell>
								</td>
								</template>
							</tr>
						</tbody>
					</template>
					<template v-else>
						<tbody><tr><td>
							Dimensions &gt; 3 non support&eacute; !
						</td></tr></tbody>
					</template>
				</table>` // Note : une solution générale est possible, mais un peu illisible... et moins souple sur le rendu.
		};




		var PricingTest_Form = {
			props: {
				ui_state: Object
			},
			template: '#PricingTest-Form-template'
		};

		/** Splitting to array */
		var SplittingInput = {
			props: {
				modelValue: Array
			},
			emits: ['update:modelValue'],
			computed: {
				value: {
					get() {
						return this.modelValue.join(" ; ");
					},
					set(value) {
						let arrValue =  value.split(";").map(s => s.trim());
						//if you arrValue.sort(); you'll need to .lazy the v-model in template
						this.$emit('update:modelValue', arrValue);
					}
				}
			},
			template: `<input v-model="value" />`
		};



		gridBuilderApp.component("splitting-input", SplittingInput);

		gridBuilderApp.component("pricinggrids-tabs", PricingGrids_Tabs);

		gridBuilderApp.component("pricinggrids-grid", PricingGrids_Grid);
		gridBuilderApp.component("pricinggrids-gridcell", PricingGrids_GridCell);

		gridBuilderApp.component("pricinggrids-dim-list", PricingGrids_DimensionList);


		gridBuilderApp.component("pricingtest-form", PricingTest_Form);

		gridBuilderApp.mount('#grid-builder');
	</script>

</body>



</html>
